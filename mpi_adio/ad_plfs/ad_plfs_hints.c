/*
 *   Copyright 2011 Cray Inc. All Rights Reserved.
 */
/*   TODO: other copyrights are probably appropriate. */

#include "ad_plfs.h"

#define POORMANS_GDB \
    printf("%d in %s:%d\n", rank, __FUNCTION__,__LINE__);
#ifdef ROMIO_CRAY
#include "../ad_cray/ad_cray.h"
#endif /* ROMIO_CRAY */


void ADIOI_PLFS_SetInfo(ADIO_File fd, MPI_Info users_info, int *error_code)
{
    static char myname[] = "ADIOI_PLFS_SETINFO";
    char *value;
    int flag, tmp_val = -1, save_val = -1;  
    int rank, i, gen_error_code;

    MPI_Comm_rank( fd->comm, &rank );
    *error_code = MPI_SUCCESS;
    #ifdef ROMIO_CRAY
       /* Process any hints set with the MPICH_MPIIO_HINTS
          environment variable. */
       ADIOI_CRAY_getenv_mpiio_hints(&users_info, fd);
    #endif /* ROMIO_CRAY */

        // here's the way to check whether we're in container mode
        // in case we want to error out if people try non-sensical hints
    if (plfs_get_filetype(fd->filename) != CONTAINER) {
        // not currently do any checking here
    }

    // if the hint structure hasn't already been created
    // however, if users_info==MPI_INFO_NULL, maybe we don't need to do this
    if ((fd->info) == MPI_INFO_NULL) {
        MPI_Info_create(&(fd->info));
    }

    /*
     * For every plfs hint, go through and check whether every rank
     * got the same value.  If not, abort.  Then copy the value from
     * the incoming MPI_Info into the ADIO_File info.
     */
    if (users_info != MPI_INFO_NULL) {
        static const char *phints[] = { 
            "plfs_disable_broadcast",   /* don't have 0 broadcast to all */ 
            "plfs_flatten_close",       /* create flattened index on close */
            "plfs_disable_paropen",     /* don't do par_index_read */
            "plfs_uniform_restart",     /* only read one index file each */ 
            NULL    /* last must be NULL */
        };

        value = (char *) ADIOI_Malloc((MPI_MAX_INFO_VAL+1)*sizeof(char));
        for(i = 0; phints[i] != NULL; i++) {
            MPI_Info_get(users_info, (char *)phints[i], MPI_MAX_INFO_VAL, value, &flag);
            if (flag) {
                save_val = tmp_val = atoi(value);
                MPI_Bcast(&tmp_val, 1, MPI_INT, 0, fd->comm);
                if (tmp_val != save_val) {  /* same for all? */
                    FPRINTF(stderr, "%s: " "the value for key \"%s\" must be "
                            "the same on all processes\n", myname, phints[i]);
                    MPI_Abort(MPI_COMM_WORLD, 1);
                }
                MPI_Info_set(fd->info, (char *)phints[i], value);
                //fprintf(stderr, "rank %d: set %s -> %s\n",rank,phints[i],value);
            }
        }
        ADIOI_Free(value);
    }
    
    #ifdef ROMIO_CRAY /* --BEGIN CRAY ADDITION-- */
        /* Calling the CRAY SetInfo() will add the Cray supported features:
         * - set the number of aggregators to the number of compute nodes
         * - MPICH_MPIIO_HINTS environment variable
         * - MPICH_MPIIO_HINTS_DISPLAY env var to display of hints values
         * - etc
         */
        ADIOI_CRAY_SetInfo(fd, users_info, &gen_error_code); 
    #else
        ADIOI_GEN_SetInfo(fd, users_info, &gen_error_code); 
    #endif /* --END CRAY ADDITION-- */

    /* If this function is successful, use the error code
     * returned from ADIOI_GEN_SetInfo
     * otherwise use the error_code generated by this function
     */
    if(*error_code == MPI_SUCCESS) {
        *error_code = gen_error_code;
    }
}
