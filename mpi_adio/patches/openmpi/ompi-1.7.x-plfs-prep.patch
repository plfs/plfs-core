diff -Naur openmpi-1.7.1/ompi/mca/io/romio/romio/adio/common/ad_fstype.c openmpi-1.7.1-plfs/ompi/mca/io/romio/romio/adio/common/ad_fstype.c
--- openmpi-1.7.1/ompi/mca/io/romio/romio/adio/common/ad_fstype.c	2013-04-13 04:44:29.000000000 -0600
+++ openmpi-1.7.1-plfs/ompi/mca/io/romio/romio/adio/common/ad_fstype.c	2013-05-22 10:58:26.557667000 -0600
@@ -510,6 +510,9 @@
     else if (!strncmp(filename, "panfs:", 6) || !strncmp(filename, "PANFS:", 6)) {
 	*fstype = ADIO_PANFS;
     }
+    else if (!strncmp(filename, "plfs:", 5) || !strncmp(filename, "PLFS:", 5)) {
+	*fstype = ADIO_PLFS;
+    }
     else if (!strncmp(filename, "hfs:", 4) || !strncmp(filename, "HFS:", 4)) {
 	*fstype = ADIO_HFS;
     }
@@ -712,6 +715,16 @@
 	*ops = &ADIO_PANFS_operations;
 #endif
     }
+    if (file_system == ADIO_PLFS) {
+#ifndef ROMIO_PLFS
+	*error_code = MPIO_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE,
+					   myname, __LINE__, MPI_ERR_IO,
+					   "**iofstypeunsupported", 0);
+	return;
+#else
+	*ops = &ADIO_PLFS_operations;
+#endif
+    }
     if (file_system == ADIO_HFS) {
 #ifndef ROMIO_HFS
 	*error_code = MPIO_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE,
diff -Naur openmpi-1.7.1/ompi/mca/io/romio/romio/adio/common/ad_opencoll.c openmpi-1.7.1-plfs/ompi/mca/io/romio/romio/adio/common/ad_opencoll.c
--- openmpi-1.7.1/ompi/mca/io/romio/romio/adio/common/ad_opencoll.c	2013-04-13 04:44:29.000000000 -0600
+++ openmpi-1.7.1-plfs/ompi/mca/io/romio/romio/adio/common/ad_opencoll.c	2013-05-22 10:58:26.559370000 -0600
@@ -80,7 +80,7 @@
    in fd, so that get_amode returns the right answer. */
 
     orig_amode_wronly = access_mode;
-    if (access_mode & ADIO_WRONLY) {
+    if (access_mode & ADIO_WRONLY && fd->file_system != ADIO_PLFS) {
 	access_mode = access_mode ^ ADIO_WRONLY;
 	access_mode = access_mode | ADIO_RDWR;
     }
diff -Naur openmpi-1.7.1/ompi/mca/io/romio/romio/adio/include/adio.h openmpi-1.7.1-plfs/ompi/mca/io/romio/romio/adio/include/adio.h
--- openmpi-1.7.1/ompi/mca/io/romio/romio/adio/include/adio.h	2013-04-13 04:44:29.000000000 -0600
+++ openmpi-1.7.1-plfs/ompi/mca/io/romio/romio/adio/include/adio.h	2013-05-22 10:58:26.561938000 -0600
@@ -300,6 +300,7 @@
 #define ADIO_LUSTRE              163   /* Lustre */
 #define ADIO_BGL                 164   /* IBM BGL */
 #define ADIO_BGLOCKLESS          165   /* IBM BGL (lock-free) */
+#define ADIO_PLFS                166   /* PLFS */
 #define ADIO_ZOIDFS              167   /* ZoidFS: the I/O forwarding fs */
 
 #define ADIO_SEEK_SET            SEEK_SET
diff -Naur openmpi-1.7.1/ompi/mca/io/romio/romio/adio/include/adioi_errmsg.h openmpi-1.7.1-plfs/ompi/mca/io/romio/romio/adio/include/adioi_errmsg.h
--- openmpi-1.7.1/ompi/mca/io/romio/romio/adio/include/adioi_errmsg.h	2013-04-13 04:44:29.000000000 -0600
+++ openmpi-1.7.1-plfs/ompi/mca/io/romio/romio/adio/include/adioi_errmsg.h	2013-05-22 10:58:26.563623000 -0600
@@ -42,7 +42,7 @@
 
 MPI_ERR_IO
     MPIR_ERR_ETYPE_FRACTIONAL "Only an integral number of etypes can be accessed"
-    MPIR_ERR_NO_FSTYPE "Can't determine the file-system type. Check the filename/path you provided and try again. Otherwise, prefix the filename with a string to indicate the type of file sytem (piofs:, pfs:, nfs:, ufs:, hfs:, xfs:, sfs:, pvfs:, panfs: ftp: gsiftp:)"
+    MPIR_ERR_NO_FSTYPE "Can't determine the file-system type. Check the filename/path you provided and try again. Otherwise, prefix the filename with a string to indicate the type of file sytem (piofs:, pfs:, nfs:, ufs:, hfs:, xfs:, sfs:, pvfs:, panfs: plfs: ftp: gsiftp:)"
     MPIR_ERR_NO_PFS "ROMIO has not been configured to use the PFS file system"
     MPIR_ERR_NO_PIOFS "ROMIO has not been configured to use the PIOFS file system"
     MPIR_ERR_NO_UFS "ROMIO has not been configured to use the UFS file system"
@@ -52,6 +52,7 @@
     MPIR_ERR_NO_SFS "ROMIO has not been configured to use the SFS file system"
     MPIR_ERR_NO_PVFS "ROMIO has not been configured to use the PVFS file system"
     MPIR_ERR_NO_PANFS "ROMIO has not been configured to use the PANFS file system"
+    MPIR_ERR_NO_PLFS "ROMIO has not been configured to use the PLFS file system"
     MPIR_ERR_MULTIPLE_SPLIT_COLL "Only one active split collective I/O operation allowed per file handle"
     MPIR_ERR_NO_SPLIT_COLL "No previous split collective begin"
     MPIR_ERR_ASYNC_OUTSTANDING "There are outstanding nonblocking I/O operations on this file"
diff -Naur openmpi-1.7.1/ompi/mca/io/romio/romio/adio/include/adioi_fs_proto.h openmpi-1.7.1-plfs/ompi/mca/io/romio/romio/adio/include/adioi_fs_proto.h
--- openmpi-1.7.1/ompi/mca/io/romio/romio/adio/include/adioi_fs_proto.h	2013-04-13 04:44:29.000000000 -0600
+++ openmpi-1.7.1-plfs/ompi/mca/io/romio/romio/adio/include/adioi_fs_proto.h	2013-05-22 10:58:26.565240000 -0600
@@ -19,6 +19,11 @@
 /* prototypes are in adio/ad_panfs/ad_panfs.h */
 #endif
 
+#ifdef ROMIO_PLFS
+extern struct ADIOI_Fns_struct ADIO_PLFS_operations;
+/* prototypes are in adio/ad_plfs/ad_plfs.h */
+#endif
+
 #ifdef ROMIO_PFS
 extern struct ADIOI_Fns_struct ADIO_PFS_operations;
 /* prototypes are in adio/ad_pfs/ad_pfs.h */
diff -Naur openmpi-1.7.1/ompi/mca/io/romio/romio/adio/include/mpio_error.h openmpi-1.7.1-plfs/ompi/mca/io/romio/romio/adio/include/mpio_error.h
--- openmpi-1.7.1/ompi/mca/io/romio/romio/adio/include/mpio_error.h	2013-04-13 04:44:29.000000000 -0600
+++ openmpi-1.7.1-plfs/ompi/mca/io/romio/romio/adio/include/mpio_error.h	2013-05-22 10:58:26.566858000 -0600
@@ -52,6 +52,7 @@
 #define MPIR_ERR_NO_HFS 15
 #define MPIR_ERR_NO_XFS 17
 #define MPIR_ERR_NO_SFS 19
+#define MPIR_ERR_NO_PLFS 20
 #define MPIR_ERR_NO_PVFS 21
 #define MPIR_ERR_NO_PANFS 22
 #define MPIR_ERR_MULTIPLE_SPLIT_COLL 23
diff -Naur openmpi-1.7.1/ompi/mca/io/romio/romio/adio/Makefile.am openmpi-1.7.1-plfs/ompi/mca/io/romio/romio/adio/Makefile.am
--- openmpi-1.7.1/ompi/mca/io/romio/romio/adio/Makefile.am	2013-04-13 04:44:30.000000000 -0600
+++ openmpi-1.7.1-plfs/ompi/mca/io/romio/romio/adio/Makefile.am	2013-05-22 10:58:26.554860000 -0600
@@ -87,6 +87,14 @@
 PANFS_LIB =
 endif
 
+if BUILD_PLFS
+PLFS_DIR = ad_plfs
+PLFS_LIB = ad_plfs/libadio_plfs.la
+else
+PLFS_DIR =
+PLFS_LIB =
+endif
+
 if BUILD_PFS
 PFS_DIR = ad_pfs
 PFS_LIB = ad_pfs/libadio_pfs.la
@@ -163,11 +171,11 @@
 SUBDIRS = common include \
 	$(BG_DIR) $(BGLOCKLESS_DIR) \
 	$(GRIDFTP_DIR) $(LUSTRE_DIR) $(NFS_DIR) $(NTFS_DIR) $(PANFS_DIR) \
-	$(PFS_DIR) $(PVFS_DIR) $(PVFS2_DIR) $(SFS_DIR) \
+	$(PLFS_DIR) $(PFS_DIR) $(PVFS_DIR) $(PVFS2_DIR) $(SFS_DIR) \
 	$(TESTFS_DIR) $(UFS_DIR) $(XFS_DIR) $(ZOID_DIR)
 DIST_SUBDIRS = common include \
         ad_bgl ad_bglockless ad_gridftp ad_lustre ad_nfs ad_ntfs \
-        ad_panfs ad_pfs ad_pvfs	ad_pvfs2 ad_sfs ad_testfs ad_ufs \
+        ad_panfs ad_plfs ad_pfs ad_pvfs	ad_pvfs2 ad_sfs ad_testfs ad_ufs \
         ad_xfs ad_zoidfs
 
 # Library
@@ -177,5 +185,5 @@
         common/libadio_common.la \
 	$(BG_LIB) $(BGLOCKLESS_LIB) \
         $(GRIDFTP_LIB) $(LUSTRE_LIB) $(NFS_LIB) $(NTFS_LIB) $(PANFS_LIB) \
-        $(PFS_LIB) $(PVFS_LIB) $(PVFS2_LIB) $(SFS_LIB) \
+        $(PLFS_LIB) $(PFS_LIB) $(PVFS_LIB) $(PVFS2_LIB) $(SFS_LIB) \
         $(TESTFS_LIB) $(UFS_LIB) $(XFS_LIB) $(ZOID_LIB)
diff -Naur openmpi-1.7.1/ompi/mca/io/romio/romio/configure.in openmpi-1.7.1-plfs/ompi/mca/io/romio/romio/configure.in
--- openmpi-1.7.1/ompi/mca/io/romio/romio/configure.in	2013-04-13 04:44:31.000000000 -0600
+++ openmpi-1.7.1-plfs/ompi/mca/io/romio/romio/configure.in	2013-05-22 10:58:26.549712000 -0600
@@ -145,7 +145,7 @@
 #
 have_aio=no
 #
-known_filesystems="nfs ufs pfs pvfs pvfs2 testfs xfs panfs gridftp lustre bgl bglockless zoidfs"
+known_filesystems="nfs ufs pfs pvfs pvfs2 testfs xfs panfs plfs gridftp lustre bgl bglockless zoidfs"
 # Open MPI: added "open_mpi_mpi"
 known_mpi_impls="mpich2_mpi mpich_mpi sgi_mpi hp_mpi cray_mpi lam_mpi open_mpi_mpi"
 #
@@ -1176,6 +1176,9 @@
 if test -n "$file_system_panfs"; then
     AC_DEFINE(ROMIO_PANFS,1,[Define for ROMIO with PANFS])
 fi
+if test -n "$file_system_plfs"; then
+    AC_DEFINE(ROMIO_PLFS,1,[Define for ROMIO with PLFS])
+fi
 if test -n "$file_system_ufs"; then
     AC_DEFINE(ROMIO_UFS,1,[Define for ROMIO with UFS])
 fi
@@ -2127,7 +2130,7 @@
 
 # Open MPI: setup the AM_CONDITIONALs to build the different adio devices
  m4_foreach([my_fs], 
-  [bgl, bglockless, gridftp, lustre, nfs, panfs, pfs, pvfs, pvfs2, sfs, testfs, ufs, xfs, zoidfs],
+  [bgl, bglockless, gridftp, lustre, nfs, panfs, pfs, pvfs, pvfs2, sfs, testfs, ufs, xfs, zoidfs, plfs],
   [AM_CONDITIONAL(BUILD_[]AS_TR_CPP(my_fs), [test -n "$file_system_]my_fs["])])
 
 echo "setting CC to $CC"
@@ -2256,6 +2259,7 @@
     adio/ad_nfs/Makefile 
     adio/ad_ntfs/Makefile 
     adio/ad_panfs/Makefile
+    adio/ad_plfs/Makefile
     adio/ad_pfs/Makefile
     adio/ad_pvfs/Makefile
     adio/ad_pvfs2/Makefile
diff -Naur openmpi-1.7.1/ompi/mca/io/romio/romio/configure.in.orig openmpi-1.7.1-plfs/ompi/mca/io/romio/romio/configure.in.orig
--- openmpi-1.7.1/ompi/mca/io/romio/romio/configure.in.orig	1969-12-31 17:00:00.000000000 -0700
+++ openmpi-1.7.1-plfs/ompi/mca/io/romio/romio/configure.in.orig	2013-05-22 10:48:56.531856000 -0600
@@ -0,0 +1,2317 @@
+# -*- Mode: shell-script -*-
+# build with
+# autoconf --localdir=../confdb configure.in
+# (or wherever the confdb is)
+#
+# irrelevant / unnecessary in an Open MPI environment, but are
+# harmless and are left here solely for the sake of ease of future
+# patching/importing.
+
+# Open MPI: Modifications to this file were done on an "let's do the
+# minimum possible" basis, not so that we can skip on the work or
+# provide any less functionality, but more from a perspective that we
+# want to be able to import new versions of ROMIO in as easy a fashion
+# as possible.  Hence, there are some things in this file that are
+# irrelevant / unnecessary in an Open MPI environment, but are
+# harmless and are left here solely for the sake of ease of future
+# patching/importing.
+
+
+AC_PREREQ(2.59)
+
+# if this blows up, it's because you forgot to run autoheader
+# Open MPI: changed to 4 arg AC INIT
+AC_INIT([romio], [Open MPI 1.2.6], [http://www.mpich.org], [romio])
+# VERSION=1.2.6
+# AC_MSG_RESULT([Configuring ROMIO Version $VERSION])
+CONFIGURE_ARGS="$*"
+if test -n "$CONFIGURE_ARGS" ; then
+    echo "Configuring with args $CONFIGURE_ARGS"
+fi
+
+if test "$FROM_MPICH2" = "yes" ; then
+    CFLAGS="$MPICH2_INTERNAL_CFLAGS"
+    CXXFLAGS="$MPICH2_INTERNAL_CXXFLAGS"
+    FFLAGS="$MPICH2_INTERNAL_FFLAGS"
+    F90FLAGS="$MPICH2_INTERNAL_F90FLAGS"
+fi
+
+AC_CONFIG_HEADER(adio/include/romioconf.h)
+# Open MPI: added AH_TOP
+AH_TOP([#include "romioconf-undefs.h"])
+
+# Open MPI: this configure script doesn't seem to define these
+# anywhere, so just do them manually here because "we know better"
+# (i.e., Open MPI can be hard-wired to these values).
+AC_DEFINE([HAVE_MPI_OFFSET], [1], [Will always be 1 - OMPI has MPI_OFFSET])
+			   
+# Open MPI: look for top Open MPI directory
+AC_MSG_CHECKING([for Open MPI support files])
+if test -f "$srcdir/../../../../../config/ompi_mca.m4"; then
+
+    # This is needed for VPATH builds, so that it will -I the
+    # appropriate include directory (don't know why automake
+    # doesn't do this # automatically).
+
+    top_ompi_srcdir='$(top_srcdir)/../../../../..'
+    top_ompi_builddir='$(top_builddir)/../../../../..'
+    AC_MSG_RESULT([in Open MPI source tree -- good])
+    AC_SUBST(top_ompi_srcdir)
+    AC_SUBST(top_ompi_builddir)
+else
+    AC_MSG_RESULT([not found])
+    AC_MSG_WARN([*** Could not find Open MPI support files])
+    AC_MSG_WARN([*** Can only build this version of ROMIO in an Open MPI source tree])
+    AC_MSG_ERROR([*** Cannot continue])
+fi
+
+dnl
+# Open MPI: disable the f77 and f90 tests, as we provide our own
+# MPI interface and use only the C parts of ROMIO
+NOF77=1
+NOF90=1
+ARCH=""
+arch_IRIX=""
+MPI=""
+MPI_INCLUDE_DIR=""
+ROMIO_INCLUDE=""
+TEST_LIBNAME=""
+FILE_SYSTEM=""
+# Do not set variables to empty that may be communicated from the
+# outside environment (e.g., MPI_LIB, MPI_BIN_DIR, LIBNAME)
+DEBUG=no
+MIPS=0
+BITS=0
+FROM_MPICH=${FROM_MPICH:-no}
+FROM_MPICH2=${FROM_MPICH2:-no}
+if test "$FROM_MPICH" = yes -a "$FROM_MPICH2" = yes ; then
+    AC_MSG_WARN([Both FROM_MPICH and FROM_MPICH set to yes; at most one should  be yes])
+    
+fi
+FROM_LAM=${FROM_LAM:-no}
+if test "$FROM_LAM" = 1 ; then FROM_LAM=yes ; fi
+CFLAGS=${CFLAGS:-""}
+LL="lld"
+AR_LOCAL=""
+DEFINE_HAVE_MPI_GREQUEST="#undef HAVE_MPI_GREQUEST"
+HAVE_MPI_INFO=""
+BUILD_MPI_INFO=""
+MPI_FINFO1=""
+MPI_FINFO2=""
+MPI_FINFO3=""
+MPI_FINFO4=""
+MPI_FARRAY1=""
+MPI_FARRAY2=""
+MPI_FARRAY3=""
+MPI_FARRAY4=""
+MPI_FARRAY5=""
+MPI_FARRAY6=""
+MPI_FARRAY7=""
+DEFS=""
+ROMIO_LFLAGS=""
+ROMIO_TCFLAGS=""
+ROMIO_TCPPFLAGS=""
+ROMIO_TFFLAGS=""
+NOPROFILE=0
+MPIRUN=""
+FORTRAN_TEST=""
+# Open MPI: This (setting make) is a Bad Thing to do in Automake-based build systems
+# MAKE=${MAKE:-"make"}
+# foll. needed for f77 test programs
+F77GETARG="call getarg(i,str)"
+F77IARGC="iargc()"
+F77MPIOINC=""
+FTESTDEFINE=""
+FORTRAN_MPI_OFFSET=""
+MPIOF_H_INCLUDED=0
+MPI_OFFSET_KIND1="!"
+MPI_OFFSET_KIND2="!"
+TEST_CC=""
+TEST_F77=""
+# Open MPI: don't want a profiling layer... - change weak from 1 to 0
+TRY_WEAK_SYMBOLS=0
+#
+# Error handlers (not used with MPICH2, which provides its own routines)
+MPIO_EXTRA_OBJECTS="get_errh.o set_errh.o"
+MPIO_EXTRA_TMP_POBJECTS="get_errh.p set_errh.p"
+MPIO_EXTRA_REAL_POBJECTS="_get_errh.o _set_errh.o"
+#
+# Completion routines for MPIO_Requests.  MPI Implementations with
+# generalized requests do not need these
+# ioreq_c2f and ioreq_f2c are not MPIO_Requests; rather, they 
+MPIO_REQOBJECTS="iotest.o iotestall.o iotestany.o iotestsome.o iowait.o iowaitall.o iowaitany.o iowaitsome.o ioreq_c2f.o ioreq_f2c.o"
+MPIO_REQ_TMP_POBJECTS="iotest.p iowait.p iowaitall.p iowaitany.p iotestall.p iotestany.p iowaitsome.p iotestsome.p"
+MPIO_REQ_REAL_POBJECTS="_iotest.o _iowait.o _iowaitall.o _iowaitany.o _iotestall.o _iotestany.o _iowaitsome.o _iotestsome.o"
+#
+have_aio=no
+#
+known_filesystems="nfs ufs pfs pvfs pvfs2 testfs xfs panfs gridftp lustre bgl bglockless zoidfs"
+# Open MPI: added "open_mpi_mpi"
+known_mpi_impls="mpich2_mpi mpich_mpi sgi_mpi hp_mpi cray_mpi lam_mpi open_mpi_mpi"
+#
+# Defaults
+AC_ARG_ENABLE(aio,[
+--enable-aio - Request use of asynchronous I/O routines (default)],
+[ 
+  if test "x$enableval" = "xno" ; then
+    disable_aio=yes
+  else
+    disable_aio=no
+  fi
+], disable_aio=no)
+AC_ARG_ENABLE(echo, 
+[--enable-echo  - Turn on strong echoing. The default is enable=no.] ,set -x)
+AC_ARG_ENABLE(f77,
+[--enable-f77 - Turn on support for Fortran 77 (default)],,enable_f77=yes)
+AC_ARG_ENABLE(f90,
+[--enable-f90 - Turn on support for Fortran 90 (default)],,enable_f90=yes)
+AC_ARG_ENABLE(weak-symbols,
+[--enable-weak-symbols - Turn on support for weak symbols],,enable_weak_symbols=yes)
+AC_ARG_ENABLE(debug,
+[--enable-debug - Build a debugging version],,)
+AC_ARG_WITH(file-system,[
+--with-file-system=name - Build with support for the named file systems],,)
+AC_ARG_WITH(pvfs2,[
+--with-pvfs2=path - Path to installation of PVFS (version 2)],,)
+AC_ARG_WITH(mpi,[
+--with-mpi=name - Specify MPI implementation to build ROMIO for],,)
+dnl
+if test "$enable_f77" != "yes" ; then
+   NOF77=1
+fi
+if test "$enable_f90" != "yes" ; then
+   NOF90=1
+fi
+if test "$enable_debug" = "yes" ; then
+    DEBUG=yes
+fi
+if test "$enable_weak_symbols" = "no" ; then
+    TRY_WEAK_SYMBOLS=0
+fi
+MPI=$with_mpi
+# Open MPI: No!
+#if test -n "$with_mpi"; then
+#       CC=$MPI/bin/mpicc
+#fi
+
+FILE_SYSTEM=$with_file_system
+#
+dnl AC_CONFIG_AUX_DIR(../../../confdb)
+dnl Set the directory that contains the required install-sh, config.sub,
+dnl and config.guess .  Make sure that these are updated (in MPICH2, use
+dnl the top-level confdb files).  This separate directory is used for
+dnl the moment to allow ROMIO to be separatedly distributed.
+dnl scripts.
+AC_CONFIG_AUX_DIR(confdb)
+
+# Check if Make is working
+PAC_PROG_MAKE
+
+# Open MPI: Init automake
+AM_INIT_AUTOMAKE([foreign])
+
+# Open MPI: If Automake supports silent rules, enable them.
+m4_ifdef([AM_SILENT_RULES], [AM_SILENT_RULES([yes])])
+
+#
+# Check that an arch was set
+# If it wasn't set, try to guess using "util/tarch"
+#
+# Sometimes tarch looses its execute bit (!)
+if test -s $srcdir/util/tarch -a ! -x $srcdir/util/tarch ; then
+    chmod a+x $srcdir/util/tarch
+fi
+if test -z "$ARCH" -a -x $srcdir/util/tarch ; then
+    AC_MSG_CHECKING(for architecture)
+    ARCH=`$srcdir/util/tarch | sed s/-/_/g`
+    if test -z "$ARCH" ; then
+       AC_MSG_RESULT(Unknown!)
+       AC_MSG_ERROR([Error: Could not guess target architecture, you must 
+set an architecture type with the environment variable ARCH]) 
+    fi 
+    eval "arch_$ARCH=1"
+    AC_MSG_RESULT($ARCH)
+fi
+#
+# check for valid architecture.  Use __ so that _ALPHA_ does not match
+# LINUX_ALPHA_
+#### WE SHOULD REMOVE THIS SOON
+grep __"$ARCH"_ $srcdir/.config_params > /dev/null 2>&1
+if test $? != 0 ; then
+   AC_MSG_WARN([Unknown architecture $arch... proceeding anyway])
+fi
+#
+#
+# Find the home directory if not specified
+if test "X$srcdir" != "X." -a -s $srcdir/mpi-io/Makefile.in ; then 
+    ROMIO_HOME_TRIAL=$srcdir
+else
+    # Take advantage of autoconf2 features
+    if test -n "$ac_confdir" ; then
+        ROMIO_HOME_TRIAL=$ac_confdir
+    else
+        if test -s configure ; then
+	    ROMIO_HOME_TRIAL=`pwd`
+	else
+	    ac_confdir=`dirname "$0" 2>/dev/null`
+	    if test -n "$ac_confdir" ; then
+	        ROMIO_HOME_TRIAL=$ac_confdir
+	    fi
+	fi
+    fi
+fi
+AC_MSG_RESULT([ROMIO home directory is $ROMIO_HOME_TRIAL])
+ROMIO_HOME=$ROMIO_HOME_TRIAL
+
+# get a fully qualified pathname for our build directory
+top_build_dir=`pwd`
+# used in romioinstall
+AC_SUBST(top_build_dir)
+
+# Open MPI: these shouldn't be needed with AM
+#
+# Create the "autoconf" style directory names...
+# Most of these are done for us; add the documentation directories
+#
+# mandir is the root for the man pages
+#if test -z "$mandir" ; then mandir='${prefix}/man' ; fi
+#AC_SUBST(mandir)
+#if test -z "$docdir" ; then docdir='${prefix}/doc' ; fi
+#AC_SUBST(docdir)
+#if test -z "$htmldir" ; then htmldir='${prefix}/www' ; fi
+#AC_SUBST(htmldir) 
+#
+# check for valid file system
+if test -n "$FILE_SYSTEM" ; then
+   # if multiple filesystems are passed in, they are '+'-delimited
+   # we could set the IFS to tokenize FILE_SYSTEM, but the FILE_SYSTEM env var
+   # is used in multiple places in the build system: get rid of the '+'s so we
+   # can use the 'for x in $FILE_SYSTEM ...' idiom 
+   FILE_SYSTEM=`echo $FILE_SYSTEM|sed -e 's/\+/ /g'`
+   for x in $FILE_SYSTEM
+   do
+      found=no
+      # We could also do test -d "ad_$y" to test for known file systems
+      # based on having access to the adio code.  Then adding a file 
+      # system would not require changing configure to change known_filesystems
+      for y in $known_filesystems ; do 
+          if test $x = $y ; then
+	      found=yes
+	      eval "file_system_`echo $x`=1"
+	      break
+	  fi
+      done
+      if test "$found" = "no" ; then
+         AC_MSG_WARN([Unknown file system $x... proceeding anyway])
+      fi
+   done
+fi
+#
+# If we are building within a known MPI implementation, we must avoid the
+# tests about an existing implementation
+if test "$FROM_MPICH" != no -o "$FROM_MPICH2" != no -o "$FROM_LAM" != no ; then
+    WITHIN_KNOWN_MPI_IMPL=yes
+else
+    WITHIN_KNOWN_MPI_IMPL=no
+fi
+
+# Open MPI: Make it think we're a known MPI implementation
+WITHIN_KNOWN_MPI_IMPL=yes
+
+# check for valid MPI implementation
+if test -n "$MPI" ; then
+   found=no
+   for mpi in $known_mpi_impls ; do
+      if test "${MPI}_mpi" = "$mpi" ; then
+          found=yes
+	  break
+      fi
+   done
+   if test $found = no ; then
+      AC_MSG_WARN([Unknown MPI implementation $MPI... proceeding anyway])
+   fi
+fi
+#
+# check for valid MPI include directory if specified
+if test $WITHIN_KNOWN_MPI_IMPL = no ; then
+   if test -n "$MPI_INCLUDE_DIR"; then
+      if test ! -f "$MPI_INCLUDE_DIR/mpi.h" ; then
+         AC_MSG_ERROR([Include file $MPI_INCLUDE_DIR/mpi.h not found])
+      fi
+   else
+#     assume that mpi.h is in the default path
+#     set MPI_INCLUDE_DIR to ".", so that it translates to -I. in the
+#     compile command. Some compilers complain if it's only -I
+      MPI_INCLUDE_DIR=.
+   fi
+else 
+   MPI_INCLUDE_DIR=.
+fi
+#
+# check for valid MPI library if specified
+if test $WITHIN_KNOWN_MPI_IMPL = no ; then
+   if test -n "$MPI_LIB" ; then
+      if test ! -f "$MPI_LIB" ; then
+         AC_MSG_ERROR([MPI library $MPI_LIB not found])
+      fi
+   fi
+fi
+#
+#
+# Open MPI - bad for Automake
+#AR="${AR:-ar} cr$AR_LOCAL"
+# Open MPI - don't test for ranlib - use AC_PROG_RANLIB all the time
+#if test -z "$RANLIB" ; then
+    AC_PROG_RANLIB
+#fi
+# Open MPI - don't set make
+# MAKE=${MAKE:-make}
+#
+# USER_CFLAGS and USER_FFLAGS are used only in test/Makefile.in
+if test $DEBUG = "yes"; then
+    USER_CFLAGS="$CFLAGS -g"
+    USER_FFLAGS="$FFLAGS -g"
+else
+    USER_CFLAGS="$CFLAGS -O"
+    USER_FFLAGS="$FFLAGS -O"
+fi
+#
+# Here begin the architecture-specific tests.  
+# --------------------------------------------------------------------------
+# We must first select the C and Fortran compilers.  Because of the 
+# way that the PROG_CC autoconf macro works (and all of the macros that
+# require it, including CHECK_HEADERS), that macro must occur exactly
+# once in the configure.in file, at least as of autoconf 2.57 .  
+# Unfortunately, this requirement is not enforced.  To handle this,
+# we first case on the architecture; then use PROG_CC, then case on the
+# architecture again for any arch-specific features.  We also set the
+# C_DEBUG_FLAG and F77_DEBUG_FLAG in case debugging is selected.
+# 
+# For the MPICH and MPICH2 configures, the compilers will already be
+# selected, so most of the compiler-selection code will be bypassed.
+# --------------------------------------------------------------------------
+# For historical reasons
+if test -z "$FC" ; then 
+    FC=$F77
+fi
+#
+C_DEBUG_FLAG="-g"
+F77_DEBUG_FLAG="-g"
+# C_OPT_FLAG=${CFLAGS:-"-O"}
+# MPICH1 uses OPTFLAGS and OPTFLAGSC to specify separate optimization
+# flags for the C compiler (this is better that adding it to the
+# undifferentiated CFLAGS, at least on input).
+if test -n "$OPTFLAGS" ; then
+    C_OPT_FLAG="$C_OPT_FLAG $OPTFLAGS"
+fi
+if test -n "$OPTFLAGSC" ; then
+    C_OPT_FLAG="$C_OPT_FLAG $OPTFLAGSC"
+fi
+# Open MPI: ignore all setting of CC, f77, FC, etc. in this section
+case $ARCH in 
+     solaris|solaris86)
+     #CC=${CC:-cc}
+     #F77=${FC:-f77}
+     if test "$CC" != "gcc" ; then
+	C_DEBUG_FLAG="-g -v"
+     fi
+     ;;
+     
+     rs6000)
+     #F77=${FC}
+     # Try to use mpcc if no CC specified
+     #AC_PROGRAMS_CHECK(CC, mpcc, cc)
+     #if test $NOF77 = 0 && test -z "$F77"; then 
+     #   AC_PROGRAMS_CHECK(F77, mpxlf, f77)
+     #fi
+     ;;
+
+     tflop|tflops)
+     #CC=${CC:-pgcc}
+     #F77=${FC:-pgf77}
+     CFLAGS="$CFLAGS -cougar -D__PUMA"
+     if test "$CC" = "pgcc" ; then
+         C_OPT_FLAG="-Knoieee -Mvect -O3"
+     fi
+     ;;
+     
+     freebsd|LINUX|netbsd|openbsd|LINUX_ALPHA)
+     #CC=${CC:-gcc}
+     # Let the prog_f77 file g77/f77/others
+     #F77=${FC} 
+     ;;
+
+     SX4)
+     #CC=${CC:-mpicc}
+     #F77=${FC:-mpif90}
+     #if test $DEBUG != "yes" ; then
+     #   USER_FFLAGS="$FFLAGS -Chopt"
+     #   F77_OPT_FLAG="-Chopt"
+     #fi
+    ;;
+
+    hpux|sppux)
+    C_DEBUG_FLAG="-g +w1"
+    ;;
+
+    alpha|ALPHA)
+    #CC=${CC:-cc}
+    #F77=${FC:-f77}
+    #dnl CFLAGS="$CFLAGS -g -std1 -warnprotos -verbose"
+    #C_DEBUG_FLAG="-g -verbose"
+    ;;
+
+    CRAY)
+    #CC=${CC:-cc}
+    #F77=${FC:-f90}
+    #NOF77=1
+    CFLAGS="$CFLAGS -D_UNICOS"
+    ;;
+
+    sgi|IRIX64|IRIX32|IRIXN32)
+    arch_IRIX=1
+    #CC=${CC:-cc}
+    #F77=${FC:-f77}
+    #C_DEBUG_FLAG="-g -fullwarn"
+    ;;
+
+    sgi5)
+    ;;
+
+    *)
+    # Fall-through case.  Take FC 
+    #F77=${FC:-f77}
+    ;;
+esac
+
+PAC_PROG_CC
+
+if test "$NOF77" != 1 ; then
+    # Grrr.   The autoconf test for F77 will abort the configure
+    # if no compiler is found.  We'd prefer to simply turn off
+    # support for Fortran, and/or give a more informative message.
+    PAC_PROG_F77
+fi
+if test "$CC" = "gcc" -a -z "$C_DEBUG_FLAG" ; then
+     C_DEBUG_FLAG="-g -O -Wall -Wstrict-prototypes -Wmissing-prototypes"
+fi
+if test $DEBUG = "yes" ; then
+    CFLAGS="$CFLAGS $C_DEBUG_FLAG"
+# Open MPI: don't add optflags - they'll come from the top-level configure
+#else 
+#    CFLAGS="$CFLAGS $C_OPT_FLAG"
+fi
+# ---------------------------------------------------------------------------
+# Here go the rest of the tests
+# ---------------------------------------------------------------------------
+if test -n "$arch_solaris" || test -n "$arch_solaris86" ; then
+    if test -z "$MPI" ; then
+        MPI=mpich
+        mpi_mpich=1
+    fi
+    if test $MPI = "mpich" ; then
+        TEST_CC=mpicc
+        TEST_F77=mpif77
+    else
+        TEST_CC="$CC"
+        TEST_F77="$F77"
+    fi
+    #OMPI: Bad for automake: AR="ar cr"
+# solaris does not have l option to ar
+fi
+
+
+if test -n "$arch_rs6000"; then
+    if test -z "$MPI" ; then
+        MPI=mpich
+        mpi_mpich=1
+    fi
+    AC_DEFINE(AIX,1,[Define for AIX])
+# assume long long exists.
+    ac_cv_sizeof_long_long=${ac_cv_sizeof_long_long:-8} 
+    MPI_OFFSET_KIND1="      INTEGER MPI_OFFSET_KIND"
+    MPI_OFFSET_KIND2="      PARAMETER (MPI_OFFSET_KIND=8)"
+    MPI_OFFSET_KIND_VAL=8
+fi    
+#
+
+if test -n "$arch_tflop" || test -n "$arch_tflops"; then
+    # TFLOP_FLAGS="-cougar -D__PUMA"
+    #OMPI: Bad for automake: AR="xar cr$AR_LOCAL"
+    #OMPI: Bad for automake: RANLIB="xranlib"
+    MPI_LIB="$MPI_LIB"
+    if test -z "$MPI" ; then
+        MPI=mpich
+        mpi_mpich=1
+    fi
+    if test -z "$FILE_SYSTEM" ; then
+        file_system_ufs=1
+        FILE_SYSTEM="ufs"
+    fi
+fi
+#
+if test -n "$arch_freebsd" || test -n "$arch_LINUX" || test -n "$arch_LINUX_ALPHA" || test -n "$arch_netbsd" || test -n "$arch_openbsd" ; then
+    if test -n "$arch_freebsd" || test -n "$arch_netbsd" || test -n "$arch_openbsd"; then
+        ac_cv_sizeof_long_long=${ac_cv_sizeof_long_long:-0}
+	# printf doesn't work properly and no integer*8 as far as I can tell
+    fi
+    # Find the CPP before the header check
+    AC_PROG_CPP
+    if test -z "$MPI" ; then
+        MPI=mpich
+        mpi_mpich=1
+    fi
+fi    
+#
+if test -n "$arch_SX4" ; then
+    have_aio=no
+    AC_DEFINE(SX4,1,[Define for NEC SX4])
+    if test -z "$MPI" ; then
+        MPI=mpich
+        mpi_mpich=1
+    fi
+    if test -z "$FILE_SYSTEM" ; then
+        file_system_sfs=1
+        file_system_nfs=1
+        FILE_SYSTEM="sfs nfs"
+    fi
+    MPI_OFFSET_KIND1="      INTEGER MPI_OFFSET_KIND"
+    MPI_OFFSET_KIND2="      PARAMETER (MPI_OFFSET_KIND=8)"
+    MPI_OFFSET_KIND_VAL=8
+fi
+#
+if test -n "$arch_hpux" || test -n "$arch_sppux" ; then
+    have_aio=no
+    #OMPI: Bad for automake: RANLIB=":"
+    if test -z "$MPI"; then
+        if test -f "/opt/mpi/include/mpi.h" ; then
+            echo "assuming that you want to use ROMIO with HP MPI"
+            MPI=hp
+        else 
+            echo "assuming that you want to use ROMIO with MPICH"
+            MPI=mpich
+        fi            
+    fi
+    if test $MPI = "mpich" ; then
+        mpi_mpich=1
+        MPI_LIB="$MPI_LIB -lV3"
+        CC=${CC:-cc -Ae}
+        F77=${FC:-f77 +U77}
+    fi
+    if test $MPI = "hp" ; then
+        mpi_hp=1
+        CC=${CC:-mpicc -Ae}
+        F77=${FC:-mpif77 +U77}
+    fi
+    if test $MPI = "lam" && test "$FC" != ""; then
+        F77="$F77 +U77"
+    fi
+    FTESTDEFINE="external iargc, getarg"
+    if test -n "$arch_hpux" ; then
+        CFLAGS="$CFLAGS -D_LARGEFILE64_SOURCE"
+        AC_DEFINE(HPUX,1,[Define for HPUX])
+        if test $MPI = "hp" ; then
+           F77=${FC:-mpif90 +U77}
+        else
+           F77=${FC:-f90 +U77}
+        fi
+    else
+        AC_DEFINE(SPPUX,1,[Define for SPPUX (Convex)])
+    fi
+
+    MPI_OFFSET_KIND1="      INTEGER MPI_OFFSET_KIND"
+    MPI_OFFSET_KIND2="      PARAMETER (MPI_OFFSET_KIND=8)"
+    MPI_OFFSET_KIND_VAL=8
+    if test "$CC" != "gcc" ; then
+        ROMIO_TCFLAGS="-Ae"
+    fi
+    if test "$F77" != "g77" ; then
+        ROMIO_TFFLAGS="+U77"
+    fi
+fi
+#
+if test -n "$arch_alpha" || test -n "$arch_ALPHA" ; then
+    if test -z "$MPI" ; then
+        MPI=mpich
+        mpi_mpich=1
+    fi
+
+    MPI_OFFSET_KIND1="      INTEGER MPI_OFFSET_KIND"
+    MPI_OFFSET_KIND2="      PARAMETER (MPI_OFFSET_KIND=8)"
+    MPI_OFFSET_KIND_VAL=8
+    LIBS="$LIBS -laio"
+fi    
+#
+if test -n "$arch_CRAY" ; then
+    NOF77=1
+    FTESTDEFINE="integer ilen"
+    F77GETARG="call pxfgetarg(i, str, ilen, ierr)"
+    have_aio=no
+    # OMPI: bad for automake: RANLIB=":"
+    AC_DEFINE(CRAY,1,[Define if Cray])
+    if test -z "$MPI" || test -n "$mpi_sgi" ; then
+        MPI=cray
+        mpi_cray=1
+        mpi_sgi=""
+# above is to disable configure tests specific to SGI MPI
+        AC_DEFINE(MPISGI,1,[Define if SGI MPI])
+        AC_DEFINE(HAVE_MPI_COMBINERS,1,[Define if MPI supports datatype combiners])
+        AC_DEFINE(NO_MPI_SGI_type_is_contig,1,[Define if no types show contig])
+    fi
+#       MPISGI needed because of error in Cray's and SGI's 
+#       MPI_Type_get_contents (does not increment reference count).
+#       Others needed because MPISGI needed.
+
+    MPI_OFFSET_KIND1="      INTEGER MPI_OFFSET_KIND"
+    MPI_OFFSET_KIND2="      PARAMETER (MPI_OFFSET_KIND=8)"
+    MPI_OFFSET_KIND_VAL=8
+fi
+#
+if test -n "$arch_sgi" ; then
+    arch_IRIX=1
+    ARCH=IRIX
+fi
+if test -n "$arch_IRIX64" || test -n "$arch_IRIX32" || test -n "$arch_IRIXN32" ; then
+    arch_IRIX=1
+fi
+if test -n "$arch_sgi5" ; then
+    arch_IRIX5=1
+    ARCH=IRIX
+fi
+#
+PAC_GET_SPECIAL_SYSTEM_INFO
+#
+# special case 'sgi5' for use on MESHINE which is much like an SGI running
+# irix 5 with r4400 chips, but does not have 'hinv', so above code doesn't
+# work
+if test -n "$arch_sgi5"; then
+   osversion=5
+   cputype=4400
+   IRIXARCH="$ARCH_$osversion"
+   IRIXARCH="$IRIXARCH_$cputype"
+# now set arch_IRIX to 1
+   arch_IRIX=1
+   echo "IRIX-specific architecture is $IRIXARCH"
+   AC_DEFINE(IRIX,1,[Define if IRIX])
+fi
+#
+if test -n "$arch_IRIX"; then
+   if test $osversion = 4 ; then
+	# OMPI: Bad for automake:RANLIB="ar ts"
+        if test -n "$mpi_sgi"; then
+            AC_MSG_ERROR([SGI\'s MPI does not work with IRIX 4.x])
+        fi
+   elif test $osversion = 5 ; then
+        if test -n "$mpi_sgi"; then
+            AC_MSG_ERROR([SGI\'s MPI does not work with IRIX 5.x])
+        fi
+   elif test $osversion = 6 ; then
+	if test -z "$MPI"; then
+	    if test "$FROM_MPICH2" = "yes" ; then
+	        # Building with MPICH2.  Distinguish from MPICH-1
+		MPI=mpich2
+		mpi_mpich2=1
+            elif test -f "/usr/include/mpi.h" ; then
+                # removed use of escaped single quotes in messages
+		# because they confuse Emacs, making it hard to 
+		# read the files (with emacs :) )
+                AC_MSG_WARN([assuming that you want to use ROMIO with the SGI MPI])
+                MPI=sgi
+                mpi_sgi=1
+            else 
+	        AC_MSG_WARN([assuming that you want to use ROMIO with MPICH])
+                MPI=mpich
+                mpi_mpich=1
+            fi            
+	fi
+         #OMPI: Bad for automake: RANLIB=":"
+        AC_DEFINE(AIO_SIGNOTIFY_NONE,1,[Define if no signotify])
+	if test $cputype -ge 5000 ; then
+            MIPS=4
+        else 
+            MIPS=3
+        fi
+   fi
+   if test -n "$mpi_sgi" && test -z "$MPI_LIB" ; then
+       MPI_LIB="-lmpi"
+   fi
+#  check if pread64 is defined
+   PAC_HAVE_PREAD64
+#
+   if test -z "$FILE_SYSTEM" ; then
+       file_system_nfs=1
+       FILE_SYSTEM="nfs"
+       AC_MSG_CHECKING(for xfs)
+       AC_TRY_COMPILE([
+#include <aio.h>],
+[aiocb64_t *t1;],file_system_xfs=1;FILE_SYSTEM="xfs $FILE_SYSTEM";)
+       if test "$file_system_xfs" = 1 ; then 
+          AC_MSG_RESULT(yes)
+       else
+          AC_MSG_RESULT(no)
+          file_system_ufs=1
+          FILE_SYSTEM="ufs $FILE_SYSTEM"
+       fi
+   fi
+   AC_DEFINE(IRIX,1,[Define if IRIX])
+   MPI_OFFSET_KIND1="      INTEGER MPI_OFFSET_KIND"
+   MPI_OFFSET_KIND2="      PARAMETER (MPI_OFFSET_KIND=8)"
+   MPI_OFFSET_KIND_VAL=8
+fi
+
+AC_HAVE_FUNCS(memalign)
+
+#
+# Question: Should ROMIO under MPICH2 ignore the Fortran tests, since 
+# MPICH2 provides all of the Fortran interface routines?
+#
+if test $NOF77 = 0 ; then
+    echo "checking Fortran external names"
+    PAC_GET_FORTNAMES
+    if test -n "$WDEF" ; then
+        CFLAGS="$CFLAGS $WDEF"
+    fi
+    dnl PAC_PROG_F77_NAME_MANGLE
+    dnl (need to set the new name format)
+    rm -f test/mpif.h
+    if test "$MPI_INCLUDE_DIR" != "." && test $WITHIN_KNOWN_MPI_IMPL = no ; then
+        if test ! -d test ; then mkdir test ; fi
+        ln -s $MPI_INCLUDE_DIR/mpif.h test
+    fi
+else 
+    F77=":"
+fi
+#
+# Open MPI: We already do this test top-level
+dnl AC_C_INLINE
+
+# Header files
+# Find the CPP before the header check
+AC_PROG_CPP
+AC_CHECK_HEADERS([unistd.h fcntl.h malloc.h stddef.h sys/types.h])
+#
+
+# When compiling ROMIO on Darwin with _POSIX_C_SOURCE defined (such as when
+# using --enable-strict in MPICH2), sys/types.h does not define u_short and
+# friends unless _DARWIN_C_SOURCE is also defined (see compat(5) on a Darwin
+# box).  This would normally be fine, except sys/stat.h defines struct stat to
+# use u_long, so strict compiles fail.  One option is to also compile with
+# _DARWIN_C_SOURCE, but this disables much of the strictness that is intended
+# by _POSIX_C_SOURCE.  Instead we just define our own types if they are not
+# provided by the system.  This isn't quite as safe as typedef'ing the
+# replacement types, but it will apply to later configure tests, which is
+# important.
+AC_CHECK_TYPE([u_char],[],[AC_DEFINE_UNQUOTED([u_char],[unsigned char],[Define to "unsigned char" if sys/types.h does not define.])])
+AC_CHECK_TYPE([u_short],[],[AC_DEFINE_UNQUOTED([u_short],[unsigned short],[Define to "unsigned short" if sys/types.h does not define.])])
+AC_CHECK_TYPE([u_int],[],[AC_DEFINE_UNQUOTED([u_int],[unsigned int],[Define to "unsigned int" if sys/types.h does not define.])])
+AC_CHECK_TYPE([u_long],[],[AC_DEFINE_UNQUOTED([u_long],[unsigned long],[Define to "unsigned long" if sys/types.h does not define.])])
+
+# must come _after_ the above checks for u_char/u_short/u_int/u_long
+AC_CHECK_HEADERS([sys/attr.h])
+
+AC_CHECK_SIZEOF(int)
+AC_CHECK_SIZEOF(void *)
+AC_CACHE_CHECK([for int large enough for pointers],
+pac_cv_int_hold_pointer,[
+if test "$ac_cv_sizeof_int" = "0" -o \
+	"$ac_cv_sizeof_void_p" = "0" ; then
+    pac_cv_int_hold_pointer=unknown
+elif test "$ac_cv_sizeof_int" -lt "$ac_cv_sizeof_void_p" ; then
+    pac_cv_int_hold_pointer=no
+else
+    pac_cv_int_hold_pointer=yes
+fi
+])
+if test "$pac_cv_int_hold_pointer" != yes ; then
+    AC_DEFINE(INT_LT_POINTER,1,[Define if int smaller than pointer])
+    dnl Switch to a conforming name (start with HAVE or USE)
+    AC_DEFINE(HAVE_INT_LT_POINTER,1,[Define if int smaller than pointer])
+fi
+
+# LL is the printf-style format name for output of a MPI_Offset.
+# We have to match this to the type that we use for MPI_Offset.
+AC_CHECK_SIZEOF(long long)
+if test "$ac_cv_sizeof_long_long" != 0 ; then
+    if test "$ac_cv_sizeof_long_long" = "8" ; then
+       AC_DEFINE(HAVE_LONG_LONG_64,1,[Define if long long is 64 bits])
+       MPI_OFFSET_TYPE="long long"
+       DEFINE_MPI_OFFSET="typedef long long MPI_Offset;"
+       FORTRAN_MPI_OFFSET="integer*8"
+       LL="lld"
+    elif test "$ac_cv_sizeof_long_long" = "$ac_cv_sizeof_int" ; then
+       MPI_OFFSET_TYPE="int"
+       DEFINE_MPI_OFFSET="typedef int MPI_Offset;"
+       FORTRAN_MPI_OFFSET="integer"
+       AC_DEFINE(MPI_OFFSET_IS_INT,1,[Define if MPI_Offset is int])
+       LL="d"
+       MPI_OFFSET_KIND1="!"
+       MPI_OFFSET_KIND2="!"
+    else
+       echo "defining MPI_Offset as long in C and integer in Fortran" 
+       MPI_OFFSET_TYPE="long"
+       DEFINE_MPI_OFFSET="typedef long MPI_Offset;"
+       FORTRAN_MPI_OFFSET="integer"
+       LL="ld"
+       MPI_OFFSET_KIND1="!"
+       MPI_OFFSET_KIND2="!"
+    fi
+else
+    echo "defining MPI_Offset as long in C and integer in Fortran" 
+    MPI_OFFSET_TYPE="long"
+    DEFINE_MPI_OFFSET="typedef long MPI_Offset;"
+    FORTRAN_MPI_OFFSET="integer"
+    LL="ld"
+    MPI_OFFSET_KIND1="!"
+    MPI_OFFSET_KIND2="!"
+fi
+
+
+#
+if test -n "$ac_cv_sizeof_long_long"; then
+   if test $WITHIN_KNOWN_MPI_IMPL = no ; then
+       PAC_MPI_LONG_LONG_INT
+   else
+       AC_DEFINE(HAVE_MPI_LONG_LONG_INT,1,[Define if supports long long int])
+   fi
+fi
+#
+if test -n "$OFFSET_KIND" -a "A$MPI_OFFSET_KIND1" = "A!" ; then 
+  MPI_OFFSET_KIND1="        INTEGER MPI_OFFSET_KIND"
+  MPI_OFFSET_KIND2="        PARAMETER (MPI_OFFSET_KIND=$OFFSET_KIND)"
+  MPI_OFFSET_KIND_VAL=$OFFSET_KIND
+else
+ if test "$FORTRAN_MPI_OFFSET" = "integer*8" && test "A$MPI_OFFSET_KIND2" = "A!" && test $NOF77 = 0 && test $NOF90 = 0 ; then
+   PAC_MPI_OFFSET_KIND
+ fi
+ #
+  if test "$FORTRAN_MPI_OFFSET" = "integer" && test "A$MPI_OFFSET_KIND2" = "A!" && test $NOF77 = 0 && test $NOF90 = 0 ; then
+   PAC_MPI_OFFSET_KIND_4BYTE
+  fi
+fi
+#
+# Test that we can use the FORTRAN_MPI_OFFSET type.  If the environment
+# is a strict Fortran 90/95 or later compiler, the "integer*8" format
+# may not work.
+if test "$NOF77" = 0 ; then
+    rm -f conftest*
+    ac_cv_f77_offset_type_works=no
+    AC_MSG_CHECKING([that we can use $FORTRAN_MPI_OFFSET to declare MPI_DISPLACMENT_CURRENT])
+    cat >conftest.f <<EOF
+        program main
+        $FORTRAN_MPI_OFFSET j
+        end
+EOF
+    if $F77 -o conftest conftest.f >>config.log 2>&1 && test -x conftest ; then
+        ac_cv_f77_offset_type_works=yes
+    fi
+    rm -f conftest*
+    AC_MSG_RESULT($ac_cv_f77_offset_type_works)
+
+    if test "$ac_cv_f77_offset_type_works" != "yes" -a -n "$MPI_OFFSET_KIND_VAL"; then
+        AC_MSG_CHECKING([whether we can use KIND with the selected F77 compiler $F77])
+        ac_cv_f77_allows_offset_kind=no
+        rm -f conftest*
+        cat >conftest.f <<EOF
+        program main
+        integer (kind=$MPI_OFFSET_KIND_VAL) j
+        end
+EOF
+        if $F77 -o conftest conftest.f >>config.log 2>&1 && test -x conftest ; then
+            ac_cv_f77_allows_offset_kind=yes
+        fi
+        rm -f conftest*
+        AC_MSG_RESULT($ac_cv_f77_allows_offset_kind)
+        if test "$ac_cv_f77_allows_offset_kind" ; then
+             FORTRAN_MPI_OFFSET="integer (kind=$MPI_OFFSET_KIND_VAL)"
+        else
+             AC_MSG_WARN([Could not find a way to declare an integer type corresponding to MPI_Offset in Fortran.])
+        fi
+    fi
+fi
+
+#
+# check if MPI_Info functions are defined in the MPI implementation
+if test $WITHIN_KNOWN_MPI_IMPL = no ; then
+   PAC_MPI_INFO
+else
+   AC_DEFINE(HAVE_MPI_INFO,1,[Define if MPI Info is available])
+   HAVE_MPI_INFO="#define HAVE_MPI_INFO"
+   MPI_FINFO1="!"
+   MPI_FINFO2="!"
+   MPI_FINFO3="!"
+   MPI_FINFO4="!"
+fi   
+#
+if test -n "$mpi_sgi"; then
+dnl   if test -z "$HAVE_MPI_INFO" ; then
+dnl      PAC_CHECK_MPI_SGI_INFO_NULL  # is MPI_INFO_NULL defined in mpi.h?
+dnl   fi
+   PAC_TEST_MPI_SGI_type_is_contig
+   PAC_TEST_MPI_COMBINERS
+   PAC_TEST_MPI_HAVE_OFFSET_KIND
+fi
+#
+# check if darray and subarray constructors are defined in the MPI 
+# implementation 
+if test $WITHIN_KNOWN_MPI_IMPL = no ; then
+   PAC_MPI_DARRAY_SUBARRAY
+fi
+if test $FROM_MPICH2 = yes ; then
+   dnl Made this a message instead of a warning because the warning is
+   dnl likely to confuse users.
+   AC_MSG_RESULT([Overriding Array test for MPICH2])
+   unset BUILD_MPI_ARRAY
+   AC_DEFINE(HAVE_MPI_DARRAY_SUBARRAY,1,[Define if Darray is available])
+   HAVE_MPI_DARRAY_SUBARRAY="#define HAVE_MPI_DARRAY_SUBARRAY"
+   MPI_FARRAY1="!"
+   MPI_FARRAY2="!"
+   MPI_FARRAY3="!"
+   MPI_FARRAY4="!"
+   MPI_FARRAY5="!"
+   MPI_FARRAY6="!"
+   MPI_FARRAY7="!"
+fi   
+#
+#
+# Test for weak symbol support...
+# We can't put # in the message because it causes autoconf to generate
+# incorrect code
+HAVE_WEAK_SYMBOLS=0
+if test -n "$arch_hpux" || test -n "$arch_sppux" ; then
+# multiple secondary definitions not allowed by HP compilers
+# Fortran interface for HP already uses one secondary defn. 
+# therefore, do not use this method for profiling interface.
+# build profiling interface explicitly.
+   TRY_WEAK_SYMBOLS=0
+fi
+if test $TRY_WEAK_SYMBOLS = 1 ; then
+  AC_MSG_CHECKING([for weak symbol support])
+  AC_TRY_LINK([
+extern int PFoo(int);
+#pragma weak PFoo = Foo
+int Foo(int a) { return a; }
+],[return PFoo(1);],has_pragma_weak=1)
+  #
+  # Some systems (Linux ia64 and ecc, for example), support weak symbols
+  # only within a single object file!  This tests that case.
+  # Note that there is an extern int PFoo declaration before the
+  # pragma.  Some compilers require this in order to make the weak symbol
+  # extenally visible.  
+if test "$has_pragma_weak" = 1 ; then
+    AC_MSG_RESULT([pragma weak])
+    AC_MSG_CHECKING([that weak symbols are visible to other files])
+    rm -f conftest*
+    cat >>conftest1.c <<EOF
+extern int PFoo(int);
+#pragma weak PFoo = Foo
+int Foo(int);
+int Foo(int a) { return a; }
+EOF
+    cat >>conftest2.c <<EOF
+extern int PFoo(int);
+int main(int argc, char **argv) {
+return PFoo(0);}
+EOF
+    ac_link2='${CC-cc} -o conftest $CFLAGS $CPPFLAGS $LDFLAGS conftest1.c conftest2.c $LIBS >conftest.out 2>&1'
+    if eval $ac_link2 ; then
+        AC_MSG_RESULT(yes)
+        AC_MSG_CHECKING([that the compiler correctly implements weak symbols])
+        # The gcc 3.4.x compiler accepts the pragma weak, but does not
+        # correctly implement it on systems where the loader doesn't 
+        # support weak symbols (e.g., cygwin).  This is a bug in gcc, but it
+        # it is one that *we* have to detect.
+        rm -f conftest*
+        cat >>conftest1.c <<EOF
+extern int PFoo(int);
+#pragma weak PFoo = Foo
+int Foo(int);
+int Foo(int a) { return a; }
+EOF
+    cat >>conftest2.c <<EOF
+extern int Foo(int);
+int PFoo(int a) { return a+1;}
+int main(int argc, char **argv) {
+return Foo(0);}
+EOF
+        if eval $ac_link2 ; then
+            AC_MSG_RESULT(yes)
+            has_pragma_weak=1
+        else 
+            AC_MSG_RESULT(no)
+            echo "$ac_link2" >> config.log
+	    echo "Failed program was" >> config.log
+            cat conftest1.c >>config.log
+            cat conftest2.c >>config.log
+            if test -s conftest.out ; then cat conftest.out >> config.log ; fi
+            has_pragma_weak=0
+        fi
+    else
+      echo "$ac_link2" 1>&AC_FD_CC
+      echo "Failed program was" 1>&AC_FD_CC
+      cat conftest1.c 1>&AC_FD_CC
+      cat conftest2.c 1>&AC_FD_CC
+      if test -s conftest.out ; then cat conftest.out 1>&AC_FD_CC ; fi
+      AC_MSG_RESULT(no)
+      has_pragma_weak=0
+    fi
+    rm -f conftest*
+  fi
+  if test "$has_pragma_weak" = 1 ; then
+    HAVE_WEAK_SYMBOLS=1
+    AC_DEFINE(HAVE_PRAGMA_WEAK,1,[Define if pragma weak available])
+  else
+    AC_TRY_LINK([
+extern int PFoo(int);
+#pragma _HP_SECONDARY_DEF Foo PFoo
+int Foo(int a) { return a; }
+],[return PFoo(1);],has_pragma_hp_secondary=1)
+    if test "$has_pragma_hp_secondary" = 1 ; then 
+        AC_MSG_RESULT([pragma _HP_SECONDARY_DEF])
+        HAVE_WEAK_SYMBOLS=1
+        AC_DEFINE(HAVE_PRAGMA_HP_SEC_DEF,1,[Define for HP weak pragma])
+    else
+        AC_TRY_LINK([
+extern int PFoo(int);
+#pragma _CRI duplicate PFoo as Foo
+int Foo(int a) { return a; }
+],[return PFoo(1);],has_pragma_cri_duplicate=1)
+        if test "$has_pragma_cri_duplicate" = 1 ; then
+	    AC_MSG_RESULT([pragma _CRI duplicate x as y])
+	    HAVE_WEAK_SYMBOLS=1
+	    AC_DEFINE(HAVE_PRAGMA_CRI_DUP,1,[Define for CRAY weak dup])
+        else    
+            AC_MSG_RESULT(no)
+        fi
+    fi
+  fi
+fi
+if test "$HAVE_WEAK_SYMBOLS" = 1 ; then
+    AC_DEFINE(HAVE_WEAK_SYMBOLS,1,[Define if weak symbols available])
+fi
+AC_SUBST(HAVE_WEAK_SYMBOLS)
+
+
+
+#
+# Check whether the MPI Offset type is compatible with struct flock
+AC_MSG_CHECKING([whether struct flock compatible with MPI_Offset])
+AC_TRY_COMPILE([#include <fcntl.h>],
+[struct flock l;
+ $MPI_OFFSET_TYPE a=1;
+ l.l_start = a; 
+ l.l_len   = a;
+],pac_cv_struct_flock_and_mpi_offset=yes,pac_cv_struct_flock_and_mpi_offset=no)
+AC_MSG_RESULT($pac_cv_struct_flock_and_mpi_offset)
+# FIXME: We should look for struct flock64 and the F_SETLK64/F_GETLK64
+# ADIOI_Set_lock could use these instead.
+if test "$pac_cv_struct_flock_and_mpi_offset" = no ; then
+    AC_MSG_CHECKING([whether struct flock compatible with int])
+    AC_TRY_COMPILE([#include <fcntl.h>],
+[struct flock l;
+ int a=1;
+ l.l_start = a; 
+ l.l_len   = a;
+],pac_cv_struct_flock_and_int=yes,pac_cv_struct_flock_and_int=no)
+    AC_MSG_RESULT($pac_cv_struct_flock_and_int)
+    if test "$pac_cv_struct_flock_and_int" = yes ; then
+        AC_DEFINE(NEEDS_INT_CAST_WITH_FLOCK,1,[Define if l_start and l_len data should be cast as int])
+    fi
+    # FIXME.  Solaris header files define off_t as a UNION if 64bit file
+    # sizes are selected.  Gah!
+fi
+
+#
+# if FILE_SYSTEM is not set above, use ufs and nfs as default
+#
+if test -z "$FILE_SYSTEM" ; then
+    file_system_ufs=1
+    file_system_nfs=1
+    FILE_SYSTEM="ufs nfs"
+fi
+
+# no matter what, always build testfs
+file_system_testfs=1
+FILE_SYSTEM="testfs $FILE_SYSTEM"
+
+# An attempt to "do the right thing" with as little help from the end-user as
+# possible:
+# - if 'with-pvfs2' given, use that to find pvfs2-config.  complain if we
+#   cannot find it, as this is probably what the user would expect
+# - if we can find 'pvfs2-config' in our path, we can use it to set CFLAGS,
+#   LIBS, and LDFLAGS accordingly
+# - as a fallback, use CFLAGS, LIBS, and LDFLAGS passed in by the user
+# - don't do any of this if --with-file-system was given and did not include
+#   'pvfs2': i.e. don't surprise the user with pvfs support.
+
+AC_PATH_PROG(PVFS2_CONFIG, pvfs2-config, notfound, [${with_pvfs2}/bin:$PATH])
+if test $PVFS2_CONFIG != "notfound" ; then
+	if test -n "${with_pvfs2}" -o -n "${file_system_pvfs2}" ; then
+		# the user either told us where pvfs is or asked for it in
+		# --with-file-system (or both)
+		CFLAGS="$CFLAGS $( $PVFS2_CONFIG --cflags)"
+		LIBS="$LIBS $( $PVFS2_CONFIG --libs)"
+		FILE_SYSTEM="pvfs2 $FILE_SYSTEM"
+		file_system_pvfs2=1
+	fi
+fi
+
+if test "$PVFS2_CONFIG" = "notfound" -a -n "$with_pvfs2" ; then
+	AC_MSG_ERROR([pvfs2-config not found in $with_pvfs2])
+fi
+
+#
+# Print list of configured file systems
+#
+# TODO: REMOVE BAD ONES FROM THE LIST SOMEHOW?
+#
+AC_MSG_CHECKING([configured file systems])
+AC_MSG_RESULT([$FILE_SYSTEM])
+
+if test -n "$file_system_nfs" ; then
+    AC_DEFINE(ROMIO_NFS,1,[Define for ROMIO with NFS])
+    AC_MSG_WARN([File locks may not work with NFS.  See the Installation and
+users manual for instructions on testing and if necessary fixing this])
+fi
+
+if test -n "$file_system_panfs"; then
+    AC_DEFINE(ROMIO_PANFS,1,[Define for ROMIO with PANFS])
+fi
+if test -n "$file_system_ufs"; then
+    AC_DEFINE(ROMIO_UFS,1,[Define for ROMIO with UFS])
+fi
+if test -n "$file_system_bgl"; then	
+    AC_DEFINE(ROMIO_BGL,1,[Define for ROMIO with BGL])
+fi
+if test -n "$file_system_bglockless"; then
+    if test x"$file_system_bgl" = x ; then
+	    AC_MSG_ERROR("bglockless requested without bgl")
+    fi
+    AC_DEFINE(ROMIO_BGLOCKLESS,1,[Define for lock-free ROMIO with BGL])
+fi
+if test -n "$file_system_hfs"; then
+    AC_DEFINE(ROMIO_HFS,1,[Define for ROMIO with HFS])
+fi
+if test -n "$file_system_sfs"; then
+    AC_DEFINE(ROMIO_SFS,1,[Define for ROMIO with SFS])
+fi
+
+if test -n "$file_system_pfs"; then
+    AC_DEFINE(ROMIO_PFS,1,[Define for ROMIO with PFS])
+fi
+
+if test -n "$file_system_testfs"; then
+    AC_DEFINE(ROMIO_TESTFS,1,[Define for ROMIO with TESTFS])
+fi
+#
+# Verify presence of lustre/lustre_user.h
+#
+if test -n "$file_system_lustre"; then
+    AC_CHECK_HEADERS(lustre/lustre_user.h,
+        AC_DEFINE(ROMIO_LUSTRE,1,[Define for ROMIO with LUSTRE]),
+        AC_MSG_ERROR([LUSTRE support requested but cannot find lustre/lustre_user.h header file]),
+        [
+        #include <unistd.h>
+        #ifdef __linux__
+        #include <linux/types.h>
+        #endif
+        ]
+    )
+fi
+
+if test -n "$file_system_xfs"; then
+    AC_DEFINE(ROMIO_XFS,1,[Define for ROMIO with XFS])
+    # Check for memalign value
+    AC_CACHE_CHECK([for memory alignment needed for direct I/O],
+    pac_cv_memalignval,
+    [
+    rm -f confmemalignval
+    rm -f /tmp/romio_tmp.bin
+    AC_TRY_RUN([
+#include <stdio.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <stdio.h>
+int main(int argc, char **argv) { 
+	struct dioattr st;
+	int fd = open("/tmp/romio_tmp.bin", O_RDWR | O_CREAT, 0644);
+	FILE *f=fopen("confmemalignval","w");
+	if (fd == -1) exit(1);
+	if (!f) exit(1);
+	fcntl(fd, F_DIOINFO, &st);
+	fprintf( f, "%u\n", st.d_mem);
+	exit(0);
+	}
+	],
+	pac_cv_memalignval=`cat confmemalignval`,
+	pac_cv_memalignval="unknown",pac_cv_memalignval="unknown"
+    )
+    rm -f confmemalignval
+    rm -f /tmp/romio_tmp.bin
+    ])
+    if test -n "$pac_cv_memalignval" -a "$pac_cv_memalignval" != 0 -a \
+	"$pac_cv_memalignval" != "unknown" ; then
+        CFLAGS="$CFLAGS -DXFS_MEMALIGN=$pac_cv_memalignval"
+    else
+        AC_MSG_RESULT(assuming 128 for memory alignment)
+        CFLAGS="$CFLAGS -DXFS_MEMALIGN=128"
+    fi
+fi
+
+#
+# Verify presence of pvfs.h, issue with int64
+#
+if test -n "$file_system_pvfs"; then
+    CPPFLAGS="$CPPFLAGS $CFLAGS"
+    AC_CHECK_HEADERS(pvfs.h,
+    	AC_DEFINE(ROMIO_PVFS,1,[Define for ROMIO with PVFS]),
+	AC_MSG_ERROR([PVFS support requested but cannot find pvfs.h header file])
+	)
+    # Check for missing int64_t (intel version 8 compiler and -no-gcc
+    # selected)
+    AC_MSG_CHECKING([that pvfs.h can be compiled])
+    AC_TRY_COMPILE([
+#include <pvfs.h>
+        ],[
+        ],pvfs_header_ok=yes,pvfs_header_ok=no
+    )
+    AC_MSG_RESULT($pvfs_header_ok)
+    if test "$pvfs_header_ok" = no -a "$ac_cv_sizeof_long_long" = 8 ; then
+        AC_MSG_CHECKING([if pvfs.h can be compiled if we define int64_t])
+        # Try again, but with int64_t
+        AC_TRY_COMPILE([
+            typedef long long int int64_t;
+#include <pvfs.h>
+            ],[
+            ],
+            pvfs_header_ok="yes with int64 definition"
+        )
+        AC_MSG_RESULT($pvfs_header_ok)
+    fi
+    if test "$pvfs_header_ok" = "yes with int64 definition" ; then
+        AC_DEFINE(ROMIO_PVFS_NEEDS_INT64_DEFINITION,1,[Define if int64_t must be defined for PVFS])
+    fi
+    if test "$pvfs_header_ok" != "no" ; then
+        AC_DEFINE(ROMIO_PVFS,1,[Define for ROMIO with PVFS])
+	AC_DEFINE(HAVE_PVFS_SUPER_MAGIC, 1, [Define if PVFS_SUPER_MAGIC defined.])
+    else
+	AC_MSG_WARN(missing or broken pvfs.h header file; disabling ROMIO PVFS support)
+    fi
+fi
+
+
+
+if test -n "$file_system_zoidfs"; then
+	AC_CHECK_HEADERS(zoidfs.h,
+		AC_DEFINE(ROMIO_ZOIDFS,1,[Define for ROMIO with ZoidFD]),
+		AC_MSG_ERROR([ZoidFS support requested but cannot find zoidfs.h header file])
+	)
+fi
+
+#
+# Verify presence of pvfs2.h
+#
+if test -n "$file_system_pvfs2"; then
+    CPPFLAGS="$CPPFLAGS $CFLAGS"
+    AC_CHECK_HEADERS(pvfs2.h,
+	AC_DEFINE(ROMIO_PVFS2,1,[Define for ROMIO with PVFS2])
+	AC_DEFINE(HAVE_PVFS2_SUPER_MAGIC, 1, [Define if PVFS2_SUPER_MAGIC defined.]),
+        AC_MSG_ERROR([PVFS2 support requested but cannot find pvfs2.h header file])                                        
+    )
+fi
+
+# layout change after pvfs-2.6.3:
+if test -n "$file_system_pvfs2"; then
+    AC_COMPILE_IFELSE([
+        AC_LANG_SOURCE([
+#include <stdlib.h>
+#include "pvfs2.h"
+          int main(int argc, char **argv) { 
+	      PVFS_object_ref ref;
+	      PVFS_sys_attr attr;
+	      PVFS_sys_create(NULL, ref, attr, NULL, NULL, NULL, NULL); 
+	  return 0; }
+       ])],
+       , AC_DEFINE(HAVE_PVFS2_CREATE_WITHOUT_LAYOUT, 1, 
+       		[Define if PVFS_sys_create does not have layout parameter])
+       )
+fi
+
+
+if test -n "$file_system_gridftp"; then
+	AC_DEFINE(ROMIO_GRIDFTP, 1, [Define for ROMIO with gridftp])
+fi
+
+if test -n "$file_system_bgl"; then
+    SYSDEP_INC=-I${prefix}/include
+else
+    SYSDEP_INC=
+
+# Check for presence and characteristics of async. I/O calls if
+# not disabled.
+
+# Some systems need pthreads to get AIO to work.  However, we don't want
+# to add pthreads just because it is there, as that can cause problems
+# with some implementations of pthreads and compilers (e.g., gcc version 3
+# would fail if there was an int a[100000] on the stack if the application
+# was *linked* with pthreads, but would succeed if the application was
+# *not linked* with pthreads.
+#
+if test "x$disable_aio" = "xno" ; then
+    AC_SEARCH_LIBS(aio_write,aio rt,aio_write_found=yes,aio_write_found=no)
+    if test "$aio_write_found" = no ; then
+        # If not found, try finding pthread_create first, and if
+        # found, try the test again.
+        AC_SEARCH_LIBS(pthread_create,pthread,foundPTHREAD=yes,foundPTHREAD=no)
+        if test "$foundPTHREAD" = yes ; then
+            AC_SEARCH_LIBS(aio_write,aio rt,aio_write_found=yes,aio_write_found=no)
+        fi
+    fi
+fi
+
+if test "x$disable_aio" = "xno" -a -n "$aio_write_found" ; then
+    AC_CHECK_HEADERS(signal.h)
+    # Just because aio.h is found by CPP doesn't mean that we can use it
+    # We try to compile it, not just read it.
+    AC_MSG_CHECKING([if aio.h exists and can be compiled])
+    AC_TRY_COMPILE([
+#include <sys/types.h>
+#include <aio.h>],
+[],have_aio_h=yes,have_aio_h=no)
+    AC_MSG_RESULT($have_aio_h)
+    if test "$have_aio_h" = yes ; then
+        AC_DEFINE(HAVE_AIO_H,1,[Define if aio.h exists and can be compiled])
+    fi
+
+    AC_MSG_CHECKING([if sys/aio.h exists and can be compiled])
+    AC_TRY_COMPILE([
+#include <sys/types.h>
+#include <sys/aio.h>],
+[],have_sys_aio_h=yes,have_sys_aio_h=no)
+    AC_MSG_RESULT($have_sys_aio_h)
+    if test "$have_sys_aio_h" = yes ; then
+        AC_DEFINE(HAVE_SYS_AIO_H,1,[Define if sys/aio.h exists and can be compiled])
+    fi
+    if test "$have_aio_h" = "no" -a "$have_sys_aio_h" = "no" ; then
+    	disable_aio=yes
+    fi
+fi
+
+if test "$have_aio_h" = "yes" -o "$have_sys_aio_h" = "yes" -o "x$disable_aio" = "xno"; then
+
+    # Check that aio is available (many systems appear to have aio
+    # either installed improperly or turned off).
+    # The test is the following: if not cross compiling, try to run a 
+    # program that includes a *reference* to aio_write but does not call it
+    # If the libraries are not set up correctly, then this will fail.
+
+    AC_MSG_CHECKING([whether aio routines can be used])
+    # Include aio.h and the aiocb struct (since we'll need these to 
+    # actually use the aio_write interface).  Note that this will 
+    # fail for some pre-POSIX implementations of the aio interface 
+    # (an old IBM interface needs an fd argument as well)
+    AC_TRY_RUN([
+#include <sys/types.h>
+#ifdef HAVE_SIGNAL_H
+#include <signal.h>
+#endif
+#ifdef HAVE_AIO_H
+#include <aio.h>
+#endif
+#ifdef HAVE_SYS_AIO_H
+#include <sys/aio.h>
+#endif
+	int main(int argc, char **argv)
+	{
+            struct aiocb *aiocbp;
+	    if (argc > 10) aio_write(aiocbp);
+	    return 0;
+	}
+	],
+	aio_runs=yes
+	AC_MSG_RESULT(yes),
+	aio_runs=no
+	AC_MSG_RESULT(no),
+	aio_runs=no
+	AC_MSG_RESULT(no: aio routines disabled when cross compiling)
+    )
+    if test "$aio_runs" != "no" ; then
+	AC_DEFINE(ROMIO_HAVE_WORKING_AIO, 1, Define if AIO calls seem to work)
+    fi
+    
+    # now about that old IBM interface...
+    # modern AIO interfaces have the file descriptor in the aiocb structure,
+    # and will set ROMIO_HAVE_STRUCT_AIOCB_WITH_AIO_FILDES.  Old IBM
+    # implementations pass the file descriptor as an argument to aio_write and
+    # aio_read.  AIO still works on these platforms, but we have to test with
+    # two-argument aio_write to avoid a false negative.  no need to worry about
+    # the two-argument vs. one-argument aio_write and aio_read: ROMIO already
+    # uses ROMIO_HAVE_STRUCT_AIOCB_WITH_AIO_FILDES to call aio_write and
+    # aio_read correctly
+
+    AC_MSG_CHECKING([for obsolete two-argument aio_write])
+    AC_TRY_RUN([
+#include <sys/types.h>
+#ifdef HAVE_SIGNAL_H
+#include <signal.h>
+#endif
+#ifdef HAVE_AIO_H
+#include <aio.h>
+#endif
+#ifdef HAVE_SYS_AIO_H
+#include <sys/aio.h>
+#endif
+	int main(int argc, char **argv)
+	{
+		int fd;
+		struct aiocb *aiocbp;
+		if (argc > 10) aio_write(fd, aiocbp);
+		return 0;
+	}
+	],
+	aio_two_arg_write=yes
+	AC_MSG_RESULT(yes),
+	aio_two_arg_write=no 
+	AC_MSG_RESULT(no),
+	aio_two_arg_write=no
+	AC_MSG_RESULT(no: cannot test when cross-compiling)
+    )
+
+    if test "$aio_two_arg_write" != "no" -a "$aio_runs" != "yes" ; then
+    	AC_DEFINE(ROMIO_HAVE_WORKING_AIO, 1, Define if AIO calls seem to work)
+	AC_DEFINE(ROMIO_HAVE_AIO_CALLS_NEED_FILEDES, 1, Define if AIO calls need file descriptor)
+    fi
+
+    AC_MSG_CHECKING([for obsolete two-argument aio_suspend])
+    AC_TRY_RUN([
+#include <sys/types.h>
+#ifdef HAVE_SIGNAL_H
+#include <signal.h>
+#endif
+#ifdef HAVE_AIO_H
+#include <aio.h>
+#endif
+#ifdef HAVE_SYS_AIO_H
+#include <sys/aio.h>
+#endif
+	int main(int argc, char **argv)
+	{
+		struct aiocb *aiocbp;
+		if (argc > 10) aio_suspend(1, &aiocbp);
+		return 0;
+	}
+	],
+	aio_two_arg_suspend=yes
+	AC_MSG_RESULT(yes),
+	aio_two_arg_suspend=no 
+	AC_MSG_RESULT(no),
+	aio_two_arg_suspend=no
+	AC_MSG_RESULT(no: cannot test when cross compiling)
+    )
+
+    if test "$aio_two_arg_suspend" != "no" -a "$aio_runs" != "yes" ; then
+	AC_DEFINE(ROMIO_HAVE_AIO_SUSPEND_TWO_ARGS, 1, Define if aio_suspend needs two arguments)
+    fi
+
+    AC_MSG_CHECKING([for aio_fildes member of aiocb structure])
+    AC_TRY_COMPILE([
+#ifdef HAVE_SIGNAL_H
+#include <signal.h>
+#endif
+#ifdef HAVE_SYS_TYPES_H
+#include <sys/types.h>
+#endif
+#ifdef HAVE_AIO_H
+#include <aio.h>
+#endif
+#ifdef HAVE_SYS_AIO_H
+#include <sys/aio.h>
+#endif
+	],[
+	struct aiocb a;
+	a.aio_fildes = 0;
+	],
+	AC_MSG_RESULT(yes)
+	AC_DEFINE(ROMIO_HAVE_STRUCT_AIOCB_WITH_AIO_FILDES, 1, [Define if aiocb has aio_fildes member]),
+	AC_MSG_RESULT(no)
+    )
+    AC_MSG_CHECKING(for aio_whence member of aiocb structure)
+    AC_TRY_COMPILE([
+#ifdef HAVE_SIGNAL_H
+#include <signal.h>
+#endif
+#ifdef HAVE_SYS_TYPES_H
+#include <sys/types.h>
+#endif
+#ifdef HAVE_AIO_H
+#include <aio.h>
+#endif
+#ifdef HAVE_SYS_AIO_H
+#include <sys/aio.h>
+#endif
+#include <sys/types.h>
+#include <unistd.h>
+	],[
+	struct aiocb a;
+	a.aio_whence = SEEK_SET;
+	],
+	AC_MSG_RESULT(yes)
+	AC_DEFINE(ROMIO_HAVE_STRUCT_AIOCB_WITH_AIO_WHENCE, 1, [Define if aiocb has aio_whence member]),
+	AC_MSG_RESULT(no)
+    )
+    AC_MSG_CHECKING(for aio_handle member of aiocb structure)
+    AC_TRY_COMPILE([
+#ifdef HAVE_SIGNAL_H
+#include <signal.h>
+#endif
+#ifdef HAVE_SYS_TYPES_H
+#include <sys/types.h>
+#endif
+#ifdef HAVE_AIO_H
+#include <aio.h>
+#endif
+#ifdef HAVE_SYS_AIO_H
+#include <sys/aio.h>
+#endif
+	],[
+	struct aiocb a;
+	aio_handle_t h;
+
+	a.aio_handle = h;
+	],
+	AC_MSG_RESULT(yes)
+	AC_DEFINE(ROMIO_HAVE_STRUCT_AIOCB_WITH_AIO_HANDLE, 1, [Define if aiocb has aio_handle member]),
+	AC_MSG_RESULT(no)
+    )
+    AC_MSG_CHECKING(for aio_reqprio member of aiocb structure)
+    AC_TRY_COMPILE([
+#ifdef HAVE_SIGNAL_H
+#include <signal.h>
+#endif
+#ifdef HAVE_SYS_TYPES_H
+#include <sys/types.h>
+#endif
+#ifdef HAVE_AIO_H
+#include <aio.h>
+#endif
+#ifdef HAVE_SYS_AIO_H
+#include <sys/aio.h>
+#endif
+	],[
+	struct aiocb a;
+
+	a.aio_reqprio = 0;
+	],
+	AC_MSG_RESULT(yes)
+	AC_DEFINE(ROMIO_HAVE_STRUCT_AIOCB_WITH_AIO_REQPRIO, 1, [Define if aiocb has aio_reqprio member]),
+	AC_MSG_RESULT(no)
+    )	
+    AC_MSG_CHECKING(for aio_sigevent member of aiocb structure)
+    AC_TRY_COMPILE([
+#ifdef HAVE_SIGNAL_H
+#include <signal.h>
+#endif
+#ifdef HAVE_SYS_TYPES_H
+#include <sys/types.h>
+#endif
+#ifdef HAVE_AIO_H
+#include <aio.h>
+#endif
+#ifdef HAVE_SYS_AIO_H
+#include <sys/aio.h>
+#endif
+	],[
+	struct aiocb a;
+
+	a.aio_sigevent.sigev_signo = 0;
+	],
+	AC_MSG_RESULT(yes)
+	AC_DEFINE(ROMIO_HAVE_STRUCT_AIOCB_WITH_AIO_SIGEVENT, 1, [Define if aiocb has aio_sigevent member]),
+	AC_MSG_RESULT(no)
+    )
+	
+fi
+fi
+# End of aio-related tests
+
+#
+# Check for statfs (many) and specifically f_fstypename field (BSD)
+#
+AC_CHECK_HEADERS(sys/vfs.h sys/param.h sys/mount.h sys/statvfs.h)
+AC_MSG_CHECKING([whether struct statfs properly defined])
+AC_TRY_COMPILE([
+#ifdef HAVE_SYS_VFS_H
+#include <sys/vfs.h>
+#endif
+#ifdef HAVE_SYS_STATVFS_H
+#include <sys/statvfs.h>
+#endif
+#ifdef HAVE_SYS_PARAM_H
+#include <sys/param.h>
+#endif
+#ifdef HAVE_SYS_MOUNT_H
+#include <sys/mount.h>
+#endif
+    ],[
+    struct statfs f;
+    ],
+    pac_cv_have_statfs=yes,pac_cv_have_statfs=no
+)
+AC_MSG_RESULT($pac_cv_have_statfs)
+# At this point, we could check for whether defining 
+# __SWORD_TYPE as sizet_t or int/long (size of pointer)
+# would help.  FIXME
+
+if test "$pac_cv_have_statfs" = yes ; then
+    AC_DEFINE(HAVE_STRUCT_STATFS,1,[Define if struct statfs can be compiled])
+fi
+	  
+AC_MSG_CHECKING([for f_fstypename member of statfs structure])
+AC_TRY_COMPILE([
+#include <sys/param.h>
+#include <sys/mount.h>
+#include <string.h>
+    ],[
+    struct statfs f;
+    memset(&f, 0, sizeof(f));
+    strncmp("nfs", f.f_fstypename, 3);
+    ],
+    pac_cv_have_statfs_f_fstypename=yes,
+    pac_cv_have_statfs_f_fstypename=no
+)
+AC_MSG_RESULT($pac_cv_have_statfs_f_fstypename)
+if test $pac_cv_have_statfs_f_fstypename = yes ; then
+    AC_DEFINE(ROMIO_HAVE_STRUCT_STATFS_WITH_F_FSTYPENAME, 1,[Define if statfs has f_fstypename])
+fi
+
+#
+# Check for stat and st_fstype field (NEC SX4)
+#
+AC_CHECK_HEADERS(sys/stat.h sys/types.h unistd.h)
+AC_CHECK_FUNCS(stat,
+    AC_DEFINE(HAVE_STAT, 1, Define if stat function is present)
+    AC_MSG_CHECKING([for st_fstype member of stat structure])
+    AC_TRY_COMPILE([
+#ifdef HAVE_SYS_TYPES_H
+#include <sys/types.h>
+#endif
+#ifdef HAVE_SYS_STAT_H
+#include <sys/stat.h>
+#endif
+#ifdef HAVE_UNISTD_H
+#include <unistd.h>
+#endif
+	],[
+	struct stat s;
+
+	s.st_fstype = NULL;
+	],
+	AC_MSG_RESULT(yes)
+	AC_DEFINE(ROMIO_HAVE_STRUCT_STAT_WITH_ST_FSTYPE, 1, Define if struct stat has a st_fstype member),
+	AC_MSG_RESULT(no)
+    )
+)
+
+#
+# Check for statvfs and f_basetype field (Solaris, Irix, AIX, etc.)
+#
+AC_CHECK_HEADERS(sys/types.h sys/statvfs.h sys/vfs.h)
+AC_CHECK_FUNCS(statvfs,
+    AC_DEFINE(HAVE_STATVFS, 1, Define if statvfs function is present)
+    AC_MSG_CHECKING([for f_basetype member of statvfs structure])
+    AC_TRY_COMPILE([
+#ifdef HAVE_SYS_TYPES_H
+#include <sys/types.h>
+#endif
+#ifdef HAVE_SYS_VFS_H
+#include <sys/vfs.h>
+#endif
+#ifdef HAVE_SYS_STATVFS_H
+#include <sys/statvfs.h>
+#endif
+	], [[
+	struct statvfs foo;
+
+	foo.f_basetype[0] = 'a';
+	]],
+	AC_MSG_RESULT(yes)
+	AC_DEFINE(ROMIO_HAVE_STRUCT_STATVFS_WITH_F_BASETYPE, 1, defined if struct statvfs has a f_basetype member),
+	AC_MSG_RESULT(no)
+    )
+)
+
+#
+# Check for large file support.  Make sure that we can use the off64_t 
+# type (in some cases, it is an array, and the ROMIO code isn't prepared for
+# that).
+#
+AC_CHECK_HEADERS(unistd.h)
+if test "$ac_cv_header_unistd_h" = "yes" ; then
+    AC_CACHE_CHECK([for large file defines],ac_cv_has_large_file_defines,[
+    AC_TRY_COMPILE([
+#include <unistd.h>
+        ], [
+#ifndef _LFS64_LARGEFILE
+#error no largefile defines
+#endif
+        ],ac_cv_has_large_file_defines=yes,ac_cv_has_large_file_defines=no)])
+    if test "$ac_cv_has_large_file_defines" = "yes" ; then
+        # See if we can use them
+    AC_CACHE_CHECK([whether off64_t is an scalar type],ac_cv_off64_t_scalar,[
+    AC_TRY_COMPILE([
+#define _LARGEFILE64_SOURCE
+#define _FILE_OFFSET_BITS 64
+#include <sys/types.h>
+#include <unistd.h>
+],[off64_t a = 3;],ac_cv_off64_t_scalar=yes,ac_cv_off64_t_scalar=no)])
+
+        if test "$ac_cv_off64_t_scalar" = "yes" ; then
+            CFLAGS="${CFLAGS} -D_LARGEFILE64_SOURCE -D_FILE_OFFSET_BITS=64"
+        fi
+    fi
+fi
+
+
+####################################################################
+# We're about to mess with CC etc.  No more feature tests past here,
+# because we may set CC to something that does not yet exist!
+####################################################################
+
+if test -n "$mpi_mpich"; then
+   if test -z "$arch_SX4" ; then
+      MPIOF_H_INCLUDED=1
+   fi
+   if test "$FROM_MPICH2" = no; then
+      AC_DEFINE(NEEDS_MPI_TEST,1,[Define if mpi_test needed])
+      AC_DEFINE(MPICH,1,[Define if using MPICH])
+   fi
+fi
+
+if test -n "$mpi_sgi"; then
+   AC_DEFINE(MPISGI,1,[Define if SGI MPI])
+fi
+
+if test -n "$mpi_lam"; then
+   AC_DEFINE(MPILAM,1,[Define if using LAM/MPI])
+fi
+
+if test -n "$mpi_hp"; then
+   AC_DEFINE(MPIHP,1,[Define if using HP MPI])
+   if test "$NOF77" = 0; then
+      PAC_CHECK_MPIOF_H
+   fi
+fi
+#
+AC_CHECK_FUNCS(strerror)
+if test -z "$srcdir" -o "$srcdir" = "." ; then srcdir="$ROMIO_HOME" ; fi
+AC_SUBST(srcdir)
+# The master_top_srcdir is the location of the source for the building
+# package.  This is used only as part of the MPICH2 build, including 
+# the documentation targets mandoc, htmldoc, and latexdoc
+if test -z "$master_top_srcdir" ; then
+    if test "$FROM_MPICH2" = yes ; then
+        AC_MSG_WARN([Could not determine master_top_srcdir])
+    fi
+fi
+AC_SUBST(master_top_srcdir)
+#
+# Get the master builddir (which may be imported from above)
+if test -z "$master_top_builddir" ; then
+    master_top_builddir=`pwd`
+fi
+export master_top_builddir
+AC_SUBST(master_top_builddir)
+# Make sure the alternate spelling is used until we clean up all of the code
+master_topbuild_dir=$master_top_builddir
+export master_topbuild_dir
+AC_SUBST(master_topbuild_dir)
+
+# The following definitions are needed within adio/common/status_setb.c
+if test "$FROM_MPICH" = yes ; then
+   AC_DEFINE(MPICH,1,[Define if compiling within MPICH])
+elif test "$FROM_MPICH2" = yes ; then 
+   AC_DEFINE(ROMIO_INSIDE_MPICH2,1,[Define if compiling within MPICH2])
+elif test "$FROM_MPILAM" = yes ; then
+   AC_DEFINE(MPILAM,1,[Define if compiling within LAM/MPI])
+fi
+
+if test "$FROM_MPICH2" = no -a "$FROM_MPICH" = no ; then 
+    if test -z "$LIBNAME"; then
+        LIBNAME="$top_build_dir/lib/libmpio.a"
+    fi
+    #
+    if test ! -d $top_build_dir/lib ; then 
+        mkdir $top_build_dir/lib
+    fi
+else
+    MPILIBNAME=${MPILIBNAME:-mpich}
+    if test -z "$LIBNAME" ; then
+        if test -d "$master_top_builddir/lib" ; then
+            LIBNAME=$master_top_builddir/lib/lib${MPILIBNAME}.a
+        else
+            LIBNAME="$ROMIO_HOME/lib${MPILIBNAME}.a"
+	fi
+    fi
+fi
+if test "$FROM_MPICH2" != no ; then
+    # use the error handlers from MPICH2
+    MPIO_EXTRA_OBJECTS=
+    MPIO_EXTRA_TMP_POBJECTS=
+    MPIO_EXTRA_REAL_POBJECTS=
+    # Use generalized request to get the multiple-completion routines
+    MPIO_REQOBJECTS=
+    MPIO_REQ_TMP_POBJECTS=
+    MPIO_REQ_REAL_POBJECTS=
+fi
+AC_SUBST(MPIO_EXTRA_OBJECTS)
+AC_SUBST(MPIO_EXTRA_TMP_POBJECTS)
+AC_SUBST(MPIO_EXTRA_REAL_POBJECTS)
+AC_SUBST(MPIO_REQOBJECTS)
+AC_SUBST(MPIO_REQ_TMP_POBJECTS)
+AC_SUBST(MPIO_REQ_REAL_POBJECTS)
+#
+# Use DOCTEXT instead of doctext
+AC_CHECK_PROGS(DOCTEXT,doctext,true)
+AC_SUBST(DOCTEXT)
+#
+if test $NOF77 = 1 ; then
+   F77=":"
+else
+   FORTRAN_TEST="fperf fcoll_test fmisc pfcoll_test" 
+fi
+#
+if test $WITHIN_KNOWN_MPI_IMPL = no ; then
+   PAC_TEST_MPI
+   PAC_NEEDS_FINT
+else
+   NEEDS_MPI_FINT=""
+fi
+#
+if test "$MPI_INCLUDE_DIR" = "." ; then
+   ROMIO_INCLUDE="-I../include"
+else 
+   ROMIO_INCLUDE="-I../include -I$MPI_INCLUDE_DIR"
+fi
+#
+TEST_LIBNAME=$LIBNAME
+MPIRUN=mpirun
+
+if test "$MPI" = "open_mpi" ; then
+
+   # Open MPI does have the status set bytes functionality
+
+   AC_DEFINE(HAVE_STATUS_SET_BYTES,1,[Define if have MPIR_Status_set_bytes])
+
+   # Used in the tests/ subdirectory for after ROMIO is built
+
+   TEST_CC=mpicc
+   TEST_F77=mpif77
+   MPIRUN=mpirun
+   MPI_LIB=
+   NOPROFILE=1
+   ROMIO_INCLUDE=
+   USER_CFLAGS=
+   USER_FFLAGS=
+   TEST_LIBNAME=
+   AC_DEFINE(HAVE_MPI_DARRAY_SUBARRAY,1,[Define if Darray is available])
+   HAVE_MPI_DARRAY_SUBARRAY="#define HAVE_MPI_DARRAY_SUBARRAY"
+   # Open MPI: see comments in mpi-io/mpioprof.h
+   AC_DEFINE(MPIO_BUILD_PROFILING, 1, [hack to make ROMIO build without profiling])
+   DEFINE_HAVE_MPI_GREQUEST="#define HAVE_MPI_GREQUEST"
+
+#
+# if MPICH, use mpicc in test programs
+#
+elif test "$FROM_MPICH" = yes ; then
+   MPICH_HOME=`dirname $ROMIO_HOME`
+   if test -z "$MPI_BIN_DIR" ; then MPI_BIN_DIR=$MPICH_HOME/bin ; fi
+   TEST_CC=$MPI_BIN_DIR/mpicc
+   MPI_LIB=""
+   ROMIO_INCLUDE=""
+   USER_CFLAGS=""
+   USER_FFLAGS=""
+   TEST_LIBNAME=""
+   MPIRUN=$MPI_BIN_DIR/mpirun
+   if test -n "$arch_SX4" || test -n "$arch_hpux" ; then
+      TEST_F77=$MPI_BIN_DIR/mpif90
+   else
+      TEST_F77=$MPI_BIN_DIR/mpif77
+   fi
+   CC=$MPI_BIN_DIR/mpicc
+   # A later test will insert the mpi2-other/info and array directories based
+   # on the value of BUILD_MPI_xxxx.  This lets MPICH2 turn these off,
+   # since MPICH2 provides these routines elsewhere
+   EXTRA_DIRS="mpi-io/fortran"
+   # Some older implementations of the ADI do not include the 
+   # MPID_Status_set_bytes routine.   This uses either the 
+   # environment variable ADI3_WITHOUT_SET_BYTES or the
+   # with arg --without-setbytes
+   if test "$ADI2_WITHOUT_SET_BYTES" != yes -a \
+           "$with_setbytes" != no ; then
+       AC_DEFINE(HAVE_STATUS_SET_BYTES,1,[Define if have MPIR_Status_set_bytes])
+   fi
+elif test $FROM_LAM = yes ; then
+   # LAM does have the status set bytes functionality
+   AC_DEFINE(HAVE_STATUS_SET_BYTES,1,[Define if have MPIR_Status_set_bytes])
+        
+   # Used in the tests/ subdirectory for after ROMIO is built
+   TEST_CC=mpicc
+   TEST_F77=mpif77
+   MPIRUN=mpirun 
+   MPI_LIB=
+   ROMIO_INCLUDE=
+   USER_CFLAGS=
+   USER_FFLAGS=
+   TEST_LIBNAME=
+   EXTRA_DIRS="mpi-io/fortran mpi2-other/info mpi2-other/info/fortran mpi2-other/array mpi2-other/array/fortran"
+elif test $FROM_MPICH2 = yes ; then
+   # For now, separate the mpich2 from mpich cases
+   MPICH_HOME=`dirname $ROMIO_HOME`
+   MPICH_HOME=`dirname $MPICH_HOME`
+   MPICH_HOME=`dirname $MPICH_HOME`
+   if test -z "$MPI_BIN_DIR" ; then MPI_BIN_DIR=$MPICH_HOME/bin ; fi
+   # No special compiler script.
+   # BUT we need the include paths
+   # CC="$CC -I${use_top_srcdir}/src/include -I${top_build_dir}/src/include"
+   # TEST_CC="$CC"
+   # MPI_LIB="$LIBNAME"
+   # To allow ROMIO to work with the LIBTOOL scripts, we want to 
+   # work directly with the CC, not the mpicc, compiler.
+   # Note that in the "FROM_MPICH2" case, the CPPFLAGS and INCLUDES are already
+   # properly set
+   #CC=${top_build_dir}/bin/mpicc
+   #
+   # set the compilers to the ones in MPICH2 bin directory (master_top_builddir/bin)
+   TEST_CC=${master_top_builddir}/bin/mpicc
+   TEST_F77=${master_top_builddir}/bin/mpif77
+   ROMIO_INCLUDE=""
+   USER_CFLAGS=""
+   USER_FFLAGS=""
+   TEST_LIBNAME=""
+   MPIRUN=${master_top_builddir}/bin/mpiexec
+   #
+   # Turn off the building of the Fortran interface and the Info routines
+   EXTRA_DIRS=""
+   AC_DEFINE(HAVE_STATUS_SET_BYTES,1,[Define if status_set_bytes available])
+   DEFINE_HAVE_MPI_GREQUEST="#define HAVE_MPI_GREQUEST 1"
+#  Open MPI does not have the MPIU functions
+#  AC_DEFINE(HAVE_MPIU_FUNCS,1,[Define if MPICH2 memory tracing macros defined])
+fi
+#
+#
+# feature tests:  we can't test features if building as part of MPICH because
+# we don't yet have an implementation against which we can test
+#
+if test $WITHIN_KNOWN_MPI_IMPL = no ; then
+   PAC_TEST_MPIR_STATUS_SET_BYTES
+   PAC_TEST_MPI_GREQUEST
+   PAC_TEST_MPIU_FUNCS
+   AC_DEFINE(PRINT_ERR_MSG,1,[Define for printing error messages])
+fi
+#
+if test -z "$TEST_CC" ; then
+   TEST_CC="$CC"
+fi
+if test -z "$TEST_F77" ; then
+   TEST_F77="$F77"
+fi
+#
+AC_CHECK_FUNCS(strdup)
+if test "$ac_cv_func_strdup" = "yes" ; then
+    # Do we need to declare strdup?
+    PAC_FUNC_NEEDS_DECL([#include <string.h>],strdup)
+fi
+AC_CHECK_FUNCS(snprintf)
+if test "$ac_cv_func_snprintf" = "yes" ; then
+    # Do we need to declare snprintf?
+    PAC_FUNC_NEEDS_DECL([#include <stdio.h>],snprintf)
+fi
+AC_CHECK_FUNCS(lstat)
+if test "$ac_cv_func_lstat" = "yes" ; then
+    # Do we need to declare lstat?
+    PAC_FUNC_NEEDS_DECL([#include <unistd.h>],lstat)
+fi
+AC_CHECK_FUNCS(readlink)
+if test "$ac_cv_func_readlink" = "yes" ; then
+    # Do we need to declare readlink?
+    PAC_FUNC_NEEDS_DECL([#include <unistd.h>],readlink)
+fi
+AC_CHECK_FUNCS(fsync)
+if test "$ac_cv_func_fsync" = "yes" ; then
+    # Do we need to declare fsync?
+    PAC_FUNC_NEEDS_DECL([#include <unistd.h>],fsync)
+fi
+AC_CHECK_FUNCS(ftruncate)
+if test "$ac_cv_func_ftruncate" = "yes" ; then
+    # Do we need to declare ftruncate?
+    PAC_FUNC_NEEDS_DECL([#include <unistd.h>],ftruncate)
+fi
+
+AC_CHECK_FUNCS(lseek64)
+if test "$ac_cv_func_lseek64" = "yes" ; then
+    PAC_FUNC_NEEDS_DECL([#include <unistd.h>],lseek64)
+fi
+#
+# Create the directory lists for the Makefile
+FILE_SYS_DIRS=""
+for dir in $FILE_SYSTEM ; do
+    FILE_SYS_DIRS="$FILE_SYS_DIRS adio/ad_$dir"
+done
+EXTRA_SRC_DIRS=""
+GLUE_DIR=""
+if test "$FROM_MPICH2" = yes -o "${MPI}_mpi" = "mpich2_mpi"; then
+    GLUE_DIR="mpi-io/glue/mpich2"
+elif test "$FROM_MPICH" = yes -o "${MPI}_mpi" = "mpich_mpi"; then
+    GLUE_DIR="mpi-io/glue/mpich1"
+else
+    GLUE_DIR="mpi-io/glue/default"
+fi
+if test "$BUILD_MPI_INFO" = 1 ; then
+    EXTRA_SRC_DIRS="$EXTRA_SRC_DIRS mpi2-other/info"
+    if test "$NOF77" = 0 -a "$FROM_MPICH2" != yes ; then
+        EXTRA_SRC_DIRS="$EXTRA_SRC_DIRS mpi2-other/info/fortran"
+    fi
+fi
+if test "$BUILD_MPI_ARRAY" = 1 ; then
+    EXTRA_SRC_DIRS="$EXTRA_SRC_DIRS mpi2-other/array"
+    if test "$NOF77" = 0 -a "$FROM_MPICH2" != yes ; then
+        EXTRA_SRC_DIRS="$EXTRA_SRC_DIRS mpi2-other/array/fortran"
+    fi
+fi
+if test "$NOF77" = 0 -a "$FROM_MPICH2" != yes ; then
+   EXTRA_SRC_DIRS="$EXTRA_SRC_DIRS mpi-io/fortran"
+fi
+AC_SUBST(EXTRA_SRC_DIRS)
+AC_SUBST(FILE_SYS_DIRS)
+AC_SUBST(GLUE_DIR)
+
+#
+CFLAGS="$CFLAGS -DHAVE_ROMIOCONF_H"
+#
+
+if test -n "$MPIOF_H_INCLUDED"; then
+   F77MPIOINC=""
+else 
+   F77MPIOINC="include 'mpiof.h'"
+fi
+
+AC_CHECK_HEADERS(unistd.h,
+        AC_MSG_CHECKING([for large file defines])
+        AC_TRY_COMPILE([
+                #include <unistd.h>
+                ], [
+                #ifndef _LFS64_LARGEFILE
+                #error no largefile defines
+                #endif
+                ],
+                CFLAGS="${CFLAGS} -D_LARGEFILE64_SOURCE -D_FILE_OFFSET_BITS=64"
+                AC_MSG_RESULT(yes),
+                AC_MSG_RESULT(none) )
+        )
+
+echo "setting SYSDEP_INC to $SYSDEP_INC"
+AC_SUBST(SYSDEP_INC)
+
+# Open MPI: use the exact same restrict test that we use in the
+# upper-level Open MPI configure script so that we always get the same
+# #define for "restrict" (there are a small number of files that will
+# end up including both ROMIO's romioconf.h and opal_config.h, so we
+# need to #defines to agree).
+AC_C_RESTRICT
+PAC_C_GNU_ATTRIBUTE
+#
+dnl CFLAGS="$CFLAGS $DEFS"
+CFLAGS="$CFLAGS -DHAVE_ROMIOCONF_H"
+#
+# Open MPI: we need libtool
+AM_PROG_LIBTOOL
+
+# Open MPI: setup the AM_CONDITIONALs to build the different adio devices
+ m4_foreach([my_fs], 
+  [bgl, bglockless, gridftp, lustre, nfs, panfs, pfs, pvfs, pvfs2, sfs, testfs, ufs, xfs, zoidfs],
+  [AM_CONDITIONAL(BUILD_[]AS_TR_CPP(my_fs), [test -n "$file_system_]my_fs["])])
+
+echo "setting CC to $CC"
+echo "setting F77 to $F77"
+echo "setting TEST_CC to $TEST_CC"
+echo "setting TEST_F77 to $TEST_F77"
+echo "setting CFLAGS to $CFLAGS"
+echo "setting USER_CFLAGS to $USER_CFLAGS"
+echo "setting USER_FFLAGS to $USER_FFLAGS"
+
+# Open MPI: Add on CFLAGS that we figured out up top.  They have
+# makefile macros in them, so we couldn't substitute them until now.
+CFLAGS="$CFLAGS $OMPI_CFLAGS "'-I$(top_builddir)/include'
+#
+# Open MPI - AM doesn't want the following:
+#   VPATH, CC, CPPFLAGS, CFLAGS, AR, RANLIB, F77, MAKE
+#VPATH='VPATH = .:${srcdir}'
+#AC_SUBST(VPATH)#
+AC_SUBST(ARCH)
+AC_SUBST(FILE_SYSTEM)
+#AC_SUBST(CC)
+#AC_SUBST(CPPFLAGS)
+#AC_SUBST(CFLAGS)
+AC_SUBST(USER_CFLAGS)
+AC_SUBST(USER_FFLAGS)
+AC_SUBST(MIPS)
+AC_SUBST(BITS)
+AC_SUBST(MPI)
+#AC_SUBST(AR)
+#AC_SUBST(RANLIB)
+AC_SUBST(MPI_INCLUDE_DIR)
+AC_SUBST(MPI_LIB)
+#AC_SUBST(F77)
+AC_SUBST(NOF77)
+AC_SUBST(NOPROFILE)
+#AC_SUBST(MAKE)
+AC_SUBST(arch_IRIX)
+AC_SUBST(ROMIO_HOME)
+AC_SUBST(LIBNAME)
+AC_SUBST(TEST_LIBNAME)
+AC_SUBST(LL)
+AC_SUBST(F77GETARG)
+AC_SUBST(F77IARGC)
+AC_SUBST(F77MPIOINC)
+AC_SUBST(FTESTDEFINE)
+AC_SUBST(FORTRAN_MPI_OFFSET)
+AC_SUBST(FROM_MPICH)
+AC_SUBST(FROM_MPICH2)
+AC_SUBST(FROM_LAM)
+AC_SUBST(WITHIN_KNOWN_MPI_IMPL)
+AC_SUBST(NEEDS_MPI_FINT)
+AC_SUBST(HAVE_MPI_INFO)
+AC_SUBST(BUILD_MPI_INFO)
+AC_SUBST(HAVE_MPI_DARRAY_SUBARRAY)
+AC_SUBST(BUILD_MPI_ARRAY)
+AC_SUBST(DEFINE_MPI_OFFSET)
+AC_SUBST(DEFINE_HAVE_MPI_GREQUEST)
+AC_SUBST(MPI_OFFSET_TYPE)
+AC_SUBST(MPI_FINFO1)
+AC_SUBST(MPI_FINFO2)
+AC_SUBST(MPI_FINFO3)
+AC_SUBST(MPI_FINFO4)
+AC_SUBST(MPI_FARRAY1)
+AC_SUBST(MPI_FARRAY2)
+AC_SUBST(MPI_FARRAY3)
+AC_SUBST(MPI_FARRAY4)
+AC_SUBST(MPI_FARRAY5)
+AC_SUBST(MPI_FARRAY6)
+AC_SUBST(MPI_FARRAY7)
+AC_SUBST(MPI_OFFSET_KIND1)
+AC_SUBST(MPI_OFFSET_KIND2)
+AC_SUBST(MPIO_REQOBJECTS)
+AC_SUBST(TEST_CC)
+AC_SUBST(TEST_F77)
+AC_SUBST(ROMIO_INCLUDE)
+AC_SUBST(ROMIO_LFLAGS)
+AC_SUBST(ROMIO_TCFLAGS)
+AC_SUBST(ROMIO_TCPPFLAGS)
+AC_SUBST(ROMIO_TFFLAGS)
+AC_SUBST(MPIRUN)
+AC_SUBST(FORTRAN_TEST)
+dnl
+# Open MPI - not needed with AM
+#dnl Dependency handling
+#AC_SUBST(MAKE_DEPEND_C)
+# Open MPI - LT / AM does all this for us...
+#dnl
+#dnl Support shared libraries
+#if test -z "$ENABLE_SHLIB" ; then
+#   ENABLE_SHLIB=none
+#fi
+#AC_SUBST(ENABLE_SHLIB)
+#AC_SUBST(CC_SHL)
+#AC_SUBST(LIBTOOL)
+# Open MPI: This is no longer necessary with modern versions of autotools
+# Remove the .a from the library file name (so that we can use .so or
+# other appropriate suffix)
+#SHLIBNAME=`echo $LIBNAME | sed 's/\.a$//'`
+#AC_SUBST(SHLIBNAME)
+#dnl
+# Open MPI: This is no longer necessary with modern versions of autotools
+#if test ! -d adio ; then mkdir adio ; fi
+#if test ! -d adio/include ; then mkdir adio/include ; fi
+#if test ! -d mpi2-other ; then mkdir mpi2-other ; fi
+#if test ! -d mpi-io ; then mkdir mpi-io ; fi
+#if test ! -d mpi-io/glue ; then mkdir mpi-io/glue ; fi
+# 
+# Make sure we remove any configuration file incase there is out-of-date data.
+# We remove the version in include in case this is a vpath build
+# Open MPI: no longer needed with modern AC
+#rm -f adio/include/romioconf.h ${use_top_srcdir}/src/mpi/romio/adio/include/romioconf.h ${use_top_srcdir}/adio/include/romioconf.h
+#
+# Create makefiles for all of the adio devices.  Only the ones that 
+# are active will be called by the top level ROMIO make
+AC_OUTPUT_COMMANDS([chmod 755 util/romioinstall test/runtests])
+# Open MPI: revamp AC_OUTPUT lines to fit Makefile.am's
+AC_CONFIG_FILES([
+    Makefile
+    localdefs 
+
+    adio/Makefile
+    adio/ad_bgl/Makefile
+    adio/ad_bglockless/Makefile
+    adio/ad_gridftp/Makefile
+    adio/ad_lustre/Makefile
+    adio/ad_nfs/Makefile 
+    adio/ad_ntfs/Makefile 
+    adio/ad_panfs/Makefile
+    adio/ad_pfs/Makefile
+    adio/ad_pvfs/Makefile
+    adio/ad_pvfs2/Makefile
+    adio/ad_sfs/Makefile
+    adio/ad_testfs/Makefile
+    adio/ad_ufs/Makefile
+    adio/ad_xfs/Makefile
+    adio/ad_zoidfs/Makefile
+    adio/common/Makefile
+    adio/include/Makefile
+
+    doc/Makefile
+
+    include/mpio.h
+    include/mpiof.h
+    include/Makefile
+
+    mpi-io/Makefile 
+
+    test/Makefile
+    test/misc.c
+    test/large_file.c
+    test/fmisc.f
+    test/fcoll_test.f
+    test/pfcoll_test.f
+    test/fperf.f
+    test/runtests
+
+    util/romioinstall
+
+    mpi-io/glue/openmpi/Makefile
+
+    util/Makefile
+])
+# Open MPI: intentionally skip the following:
+# mpi2-other/info/Makefile
+# mpi2-other/info/fortran/Makefile
+# mpi2-other/array/Makefile
+# mpi2-other/array/fortran/Makefile
+# mpi-io/fortran/Makefile
+# mpi-io/glue/mpich2/Makefile
+# mpi-io/glue/mpich1/Makefile
+# mpi-io/glue/default/Makefile
+# Open MPI: according to romio-maint@mcs.anl.gov:
+# adio/ad_hfs/Makefile: old and no longer used
+# adio/ad_ntfs/Makefile: not built with GNU Autotools
+# adio/ad_piofs/Makefile: old and no longer used
+AC_OUTPUT
+#
+#
+# Open MPI - don't need to remove this...
+# rm -f *.o
+
+# Open MPI - don't need this extra printf
+#if test $FROM_MPICH = no -a $FROM_MPICH2 = no ; then
+#   AC_MSG_RESULT([Configure done. Now type make.])
+#fi
+dnl PAC_SUBDIR_CACHE_CLEANUP
+exit 0
diff -Naur openmpi-1.7.1/ompi/mca/io/romio/romio/README openmpi-1.7.1-plfs/ompi/mca/io/romio/romio/README
--- openmpi-1.7.1/ompi/mca/io/romio/romio/README	2013-04-13 04:44:31.000000000 -0600
+++ openmpi-1.7.1-plfs/ompi/mca/io/romio/romio/README	2013-05-22 10:58:26.552598000 -0600
@@ -1,5 +1,14 @@
           ROMIO: A High-Performance, Portable MPI-IO Implementation
 
+                      Version 2012-05-16
+
+Major Changes in this version:
+------------------------------
+* added PLFS support
+  http://sourceforge.net/projects/plfs/
+  http://institutes.lanl.gov/plfs/
+
+
                       Version 2008-03-09
 
 Major Changes in this version:
