#!/usr/bin/env perl

#
# hdfswrap.pl  wrap HDFS API to limit the number of threads calling the JVM
# 30-Aug-2011  chuck@ece.cmu.edu
#

$| = 1;

use strict;

#
# getnametype(string): get name and type info
#
sub getnametype {
    my($s) = @_;
    my($pt, $p2, $name, $type);

    $pt = rindex($s, ' ');           # reverse search for ' '
    die "parse failed4 ($s)" if ($pt == -1);
    $p2 = rindex($s, '*');
    $pt = $p2 if ($p2 > $pt);        # but also handle '*'

    $type = substr($s, 0, $pt+1);    # gets the ' ' or '*'
    $type =~ s/^\s+//;               # remove leading spaces
    $type =~ s/\s+$//;               # remove trailing spaces
    $type =~ s/(\w)(\*+)$/$1 $2/;    # normalize 'char*' to 'char *'

    $name = substr($s, $pt+1);       # get name and also remove spaces
    $name =~ s/^\s+//;
    $name =~ s/\s+$//;
    
    return($name, $type);            # returns a list
}

#
# joinnametype(name,type): put name and type back together
#
sub joinnametype {
    my($name, $type) = @_;

    $_ = ($type =~ /\*$/) ? "" : " ";
    return($type . $_ . $name);
}

#
# genwrap(api): generate wrapper for an API
#
sub genwrap {
    my($a) = @_;
    my($a0, $pos, $ret, $name, @args, $n, $t, @arts, @arns, $lcv);

    # parse
    $a0 = $a;
    $pos = index($a, '(');
    die "parse failed1 ($a0)" if ($pos == -1);
    $ret = substr($a, 0, $pos);
    $a = substr($a, $pos+1);

    ($name, $ret) = getnametype($ret);

    $pos = rindex($a, ')');
    die "parse failed3 ($a0)" if ($pos == -1);
    $a = substr($a, 0, $pos);
    $a =~ s/\s+,/,/g;
    $a =~ s/,\s+/,/g;

    @args = split(/,/, $a);

    foreach $a (@args) {
        ($n, $t) = getnametype($a);
        push(@arns, $n);
        push(@arts, $t);
    }
    # all parsed!

    # generate
    safeprintf("/*\n * API function %s\n */\n", $name);

    # generate arg data structure
    safeprintf("struct %s_args {\n", $name);
    if ($ret ne 'void') {
        safeprintf("    %s_ret;\n", joinnametype($name, $ret));
    } else {
        safeprintf("    /* void fn.  no return value */\n");
    }
    for ($lcv = 0 ; $lcv <= $#arts ; $lcv++) {
        safeprintf("    %s;\n", joinnametype($arns[$lcv], $arts[$lcv]));
    }
    safeprintf("};\n\n");
    
    # generate handler
    safeprintf("void %s_handler(void *arg) {\n", $name);
    safeprintf("    struct %s_args *agp = (struct %s_args *)arg;\n", $name,
        $name);
    if ($ret ne 'void') {
        safeprintf("    agp->%s_ret = ", $name);
    }
    safeprintf("%s(", $name);
    for ($lcv = 0 ; $lcv <= $#arts ; $lcv++) {
        safeprintf("agp->%s", $arns[$lcv]);
        safeprintf(", ") if ($lcv < $#arts);
    }
    safeprintf(");\n");
    safeprintf("    return;\n}\n\n");

    # generate wrapper
    safeprintf("%s_wrap(", joinnametype($name, $ret));
    for ($lcv = 0 ; $lcv <= $#arts ; $lcv++) {
        safeprintf("%s", joinnametype($arns[$lcv], $arts[$lcv]));
        safeprintf(", ") if ($lcv < $#arts);
    }
    safeprintf(") {\n");
    safeprintf("    struct %s_args ag;\n", $name);
    for ($lcv = 0 ; $lcv <= $#arts ; $lcv++) {
        safeprintf("    ag.%s = %s;\n", $arns[$lcv], $arns[$lcv]);
    }
    safeprintf("    /* send to thread pool for execution */\n");
    safeprintf('    hdfs_execute("%s", (void *)&ag, %s_handler);%s',
               $name, $name, "\n");
    if ($ret eq 'void') {
        safeprintf("    return;    /* void, no ret val */\n");
    } else {
        safeprintf("    return(ag.%s_ret);\n", $name);
    }
    safeprintf("}\n\n");

}

#
# safeprintf: printf something, but abort if we have an error
#
sub safeprintf {
    my($rv);
    $rv = printf P @_;
    unless ($rv) {
        print "PRINTF ERROR: $!, aborting\n";
        unlink("hdfswrap.h_NEW");
        exit(1);
    }
}

#
# safeprint: print something, but abort if we have an error
#
sub safeprint {
    my($rv);
    $rv = print P @_;
    unless ($rv) {
        print "PRINT ERROR: $!, aborting\n";
        unlink("hdfswrap.h_NEW");
        exit(1);
    }
}

my($in, $out, @api, $apistring);

# slurp up the input
open($in, "HDFS.api") || die "cannot open HDFS.api ($!)";
while (<$in>) {
    next if (/^\s*#/);    # skip comment lines
    chop;
    s/\t/ /g;
    push(@api, $_);
}
close($in);

# parse the input into APIs
$apistring = join(' ', @api);
$apistring =~ s/  +/ /g;
$apistring =~ s/\s+;/;/g;
$apistring =~ s/;\s+/;/g;
@api = split(/;/, $apistring);

# make output file
open(P, ">hdfswrap.h_NEW") || die "cannot open hdfswrap.h_NEW ($!)";

$_ = <<EOD;
/*
 * hdfswrap.h  thread control wrapper for HDFS
 */

/* DO NOT EDIT -- this file is automatically generated. */

void hdfs_execute(const char *name, void *a, void (*)(void *ap));

EOD
safeprint($_);

foreach (@api) {
    genwrap($_);
}

rename("hdfswrap.h_NEW", "hdfswrap.h") || die "rename failed ($!)";
exit(0);

